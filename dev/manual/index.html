<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · SplineGrids.jl</title><meta name="title" content="Manual · SplineGrids.jl"/><meta property="og:title" content="Manual · SplineGrids.jl"/><meta property="twitter:title" content="Manual · SplineGrids.jl"/><meta name="description" content="Documentation for SplineGrids.jl."/><meta property="og:description" content="Documentation for SplineGrids.jl."/><meta property="twitter:description" content="Documentation for SplineGrids.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SplineGrids.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SplineGrids.jl</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory_refinement/">Refinement</a></li><li><a class="tocitem" href="../theory_local_refinement/">Local refinement (THB-splines)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_dimensions/">Dimensionality</a></li><li><a class="tocitem" href="../examples_nurbs/">NURBS</a></li><li><a class="tocitem" href="../examples_derivatives/">Derivatives</a></li><li><a class="tocitem" href="../examples_linear_fitting/">Linear fitting</a></li><li><a class="tocitem" href="../examples_enzyme/">Control point derivatives with Enzyme</a></li></ul></li><li><span class="tocitem">Advanced examples</span><ul><li><a class="tocitem" href="../examples_pde/">Solving a PDE</a></li><li><a class="tocitem" href="../examples_optics/">Optimizing a lens surface</a></li></ul></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li class="toplevel"><a class="tocitem" href="#Geometric-operations"><span>Geometric operations</span></a></li><li class="toplevel"><a class="tocitem" href="#Structs"><span>Structs</span></a></li><li class="toplevel"><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SouthEndMusic/SplineGrids.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/master/docs/src/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.KnotVector-Tuple{Integer, Integer}" href="#SplineGrids.KnotVector-Tuple{Integer, Integer}"><code>SplineGrids.KnotVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KnotVector(
    n_basis_functions::Integer, 
    degree::Integer; 
    extent::Tuple{Number, Number} = (0,1), 
    distribution::Symbol = :equispaced)</code></pre><p>Construct a clamped knot vector, i.e. the multiplicity of the first and last knot is degree + 1 and the other multiplicities are 1.</p><p><strong>Arguments</strong></p><ul><li><code>n_basis_functions</code>: The number of basis functions that will be defined on this knot vector</li><li><code>degree</code>: The degree of the basis functions that will be defined on this knot vector</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>extent</code>: A tuple (t<em>min, t</em>max) defining the extend of the knot vector</li><li><code>distribution</code>: The distribution of the internal knots. The options are :equispaced or :random</li><li><code>backend</code>: The KernelAbstractions backend of the arrays in the object. Defaults to <code>CPU()</code>.</li><li><code>float_type</code>: The type of all floating point arrays. Defaults to <code>Float32</code>.</li><li><code>int_type</code>: The type of all integer arrays. Defaults to <code>Int32</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/knot_vector.jl#L52-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.SplineDimension-Tuple{Integer, Integer, Integer}" href="#SplineGrids.SplineDimension-Tuple{Integer, Integer, Integer}"><code>SplineGrids.SplineDimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineDimension(
    n_basis_functions::Integer,
    degree::Integer,
    n_sample_points::Integer;
    max_derivative_order::Integer = 0,
    knot_vector::Union{Nothing, KnotVector{Tv, Ti}} = nothing,
    backend::Backend = CPU(),
    float_type::Type{Tv} = Float32,
    int_type::Type{Ti} = Int32,
    kwargs...)::SplineDimension where {Tv &lt;: AbstractFloat, Ti &lt;: Integer}</code></pre><p>Constructor for a SplineDimension. Optionally a <code>knot_vector</code> kwarg can be passed, otherwise a default knot vector is generated. For now by default the sample points are evenly spaced on the extent of the knot vector. Key word arguments are passed to the KnotVector constructor.</p><p><strong>Inputs</strong></p><ul><li><code>n_basis_functions</code>: The number of basis functions of this spline dimension</li><li><code>degree</code>: The degree of the basis functions of this spline dimension</li><li><code>n_sample_points</code>: The number of points at which the domain of the basis functions will be sampled</li><li><code>max_derivative_order</code>: The maximum derivative order of the basis functions that will be computed in <code>evaluate!</code>. Defaults to <code>0</code>. <code>knot_vector</code>: A knot vector on which the basis functions will be defined. Defaults to <code>nothing</code>, which means that a default clamped/open equally spaced knot vector will be defined.</li><li><code>backend</code>: The KernelAbstractions backend of the arrays in the object. Defaults to <code>CPU()</code>. NOTE: If a knot vector is supplied, its backend takes precedence.</li><li><code>float_type</code>: The type of all floating point arrays. Defaults to <code>Float32</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_dimension.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.SplineGrid-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nin}, Tuple{NTuple{Nin, var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:(SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}), Integer}} where {Nin, Tv, Ti}" href="#SplineGrids.SplineGrid-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nin}, Tuple{NTuple{Nin, var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:(SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}), Integer}} where {Nin, Tv, Ti}"><code>SplineGrids.SplineGrid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineGrid(spline_dimensions::NTuple{Nin, &lt;:SplineDimension{Tv, Ti}}, Nout::Integer)::SplineGrid{Nin, Tv, Ti} where {Nin, Tv, Ti}</code></pre><p>Define a <code>SplineGrid</code> from an NTuple of spline dimensions and the number of output dimensions.</p><p><strong>Inputs</strong></p><ul><li><code>spline_dimensions</code>: an NTuple of spline dimensions</li><li><code>Nout</code>: The number of output dimensions. I.e. the control points and thus the spline live in ℝ^Nout.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_grid.jl#L60-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.NURBSGrid" href="#SplineGrids.NURBSGrid"><code>SplineGrids.NURBSGrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create a SplineGrid but with preallocated weights to define a NURBS. See The SplineGrid constructors for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_grid.jl#L96-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.rmeye" href="#SplineGrids.rmeye"><code>SplineGrids.rmeye</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rmeye(
    n::Integer;
    backend::Backend = CPU(),
    float_type::Type{Tv} = Float32,
    int_type::Type{Ti} = Int)::RefinementMatrix{Tv, Ti} where {Tv, Ti &lt;: Integer}</code></pre><p>Construct an identity refinement matrix.</p><p><strong>Input</strong></p><ul><li><code>n</code>: The size of the identity matrix is n×n</li><li><code>backend</code>: The KernelAbstractions backend of the matrix data</li><li><code>float_type</code>: The value type of the matrix data</li><li><code>int_type</code>: The integer type of the matrix data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement_matrix.jl#L447-L462">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.RefinementMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, Integer, Any}} where {Tv, Ti&lt;:Integer}" href="#SplineGrids.RefinementMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, Integer, Any}} where {Tv, Ti&lt;:Integer}"><code>SplineGrids.RefinementMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefinementMatrix(
    spline_dimension::SplineDimension{Tv, Ti},
    knot_span_index::Integer,
    knot_new
    )::RefinementMatrix{Tv, Ti} where {Tv, Ti &lt;: Integer}</code></pre><p>Build a refinement matrix per row given a knot vector and a to be added new knot.</p><p><strong>Inputs</strong></p><ul><li><code>spline_dimension</code>: The spline dimension whose knot vector the new knot is to be added to</li><li><code>knot_span_index</code>: The index such that <code>knots_all[knot_span_index] ≤ knot_new &lt; knots_all[knot_span_index + 1]</code></li><li><code>knot_new</code>: The value of the new knot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement.jl#L38-L52">source</a></section></article><h1 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate!-Tuple{SplineDimension}" href="#SplineGrids.evaluate!-Tuple{SplineDimension}"><code>SplineGrids.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate!(spline_dimension)</code></pre><p>Per sample point, get the value of the <code>spline_dimension.degree + 1</code> basis functions that have a non-zero value for that sample point. This is based on the Cox-de Boor recursion formula.</p><p>The l-th sample point <code>t</code> has sample index <code>i</code>, meaning that <code>t ∈ [tᵢ, tᵢ₊₁)</code>. Therefore <code>Bᵢ₀(t) = 1, Bⱼ₀(t) = 0 for j ≠ i</code>. For degree <code>k</code>, <code>t</code> is in the domain of <code>Bⱼₖ</code> which is <code>[tⱼ, tⱼ₊ₖ₊₁)</code>, for <code>j = i - k, ..., i</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline_dimension</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_dimension.jl#L217-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false}}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout}" href="#SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false}}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout}"><code>SplineGrids.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate!(spline_grid::SplineGrid{Nin};
    derivative_order::NTuple{Nin, &lt;:Integer} = ntuple(_ -&gt; 0, Nin),
    control_points::AbstractArray = spline_grid.control_points,
    eval::AbstractArray = spline_grid.eval)</code></pre><p>Evaluate the spline grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a linear combination of control points with basis function products as coefficients.</p><p>If weights are supplied, compute the rational basis functions for NURBS as the control point coefficients.</p><p>Uses the <code>control_points</code> and <code>eval</code> arrays from the <code>spline_grid</code> by default, but different arrays can be specified as a convenience for optimization algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_grid.jl#L185-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, true, Tv, Ti} where {Nout, Tv, Ti}}, Tuple{Nin}} where Nin" href="#SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, true, Tv, Ti} where {Nout, Tv, Ti}}, Tuple{Nin}} where Nin"><code>SplineGrids.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate!(spline_grid::SplineGrid{Nin};
    derivative_order::NTuple{Nin, &lt;:Integer} = ntuple(_ -&gt; 0, Nin),
    control_points::AbstractArray = spline_grid.control_points,
    eval::AbstractArray = spline_grid.eval)</code></pre><p>Evaluate the spline grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a linear combination of control points with basis function products as coefficients.</p><p>If weights are supplied, compute the rational basis functions for NURBS as the control point coefficients.</p><p>Uses the <code>control_points</code> and <code>eval</code> arrays from the <code>spline_grid</code> by default, but different arrays can be specified as a convenience for optimization algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_grid.jl#L185-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate_adjoint!" href="#SplineGrids.evaluate_adjoint!"><code>SplineGrids.evaluate_adjoint!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate_adjoint!(spline_grid::AbstractSplineGrid{Nin, Nout, false, Tv};
    derivative_order::NTuple{Nin, &lt;:Integer} = ntuple(_ -&gt; 0, Nin),
    control_points::AbstractControlPointArray{Nin, Nout, Tv} = spline_grid.control_points,
    eval::AbstractArray = spline_grid.eval)::Nothing where {Nin, Nout, Tv}</code></pre><p>evaluate the adjoint of the linear mapping <code>control_points -&gt; eval</code>. This is a computation of the form <code>eval -&gt; control_points</code>. If we write <code>evaluate!(spline_grid)</code> as a matrix vector multiplication <code>eval = M * control_points</code>, Then the adjoint is given by <code>v -&gt; M&#39; * v</code>. This mapping is used in fitting algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/adjoint.jl#L42-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.mult!" href="#SplineGrids.mult!"><code>SplineGrids.mult!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mult!(
    Y::V,
    As::NTuple{&lt;:RefinementMatrix{Tv}, N},
    B::V,
    dims_refinement::NTuple{&lt;:Integer, N})::Nothing where {Tv, V &lt;: AbstractArray{Tv}, N}</code></pre><p>&#39;left-multiply&#39; the array B by every refinement matrix along the specified dimension.</p><p><strong>Inputs</strong></p><ul><li><code>Y</code>: The target array of the multiplication</li><li><code>As</code>: The refinement matrices <code>Y</code> will be multiplied by</li><li><code>B</code>: The array that will be multiplied by the refinement matrices</li><li><code>dims_refinement</code>: The dimension along which the refinement matrix multiplication will take place for each matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement_matrix.jl#L405-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate!-Tuple{LocallyRefinedControlPoints}" href="#SplineGrids.evaluate!-Tuple{LocallyRefinedControlPoints}"><code>SplineGrids.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the locally refined control points. For each local refinement, first apply the refinement matrix and then overwrite the desired control point values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L315-L318">source</a></section></article><h1 id="Geometric-operations"><a class="docs-heading-anchor" href="#Geometric-operations">Geometric operations</a><a id="Geometric-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-operations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.insert_knot-Tuple{KnotVector, AbstractFloat}" href="#SplineGrids.insert_knot-Tuple{KnotVector, AbstractFloat}"><code>SplineGrids.insert_knot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_knot(
knot_vector::KnotVector, 
knot_new::AbstractFloat)::Tuple{KnotVector, Integer}</code></pre><p>Create a new knot vector with the new knot of multiplicity 1.</p><p><strong>Inputs</strong></p><ul><li><code>knot_vector</code>: The knot vector object to which the knot will be added</li><li><code>knot_new</code>: The value of the new knot. Should not be part of the knot values already</li></ul><p><strong>Outputs</strong></p><ul><li><code>knot_vector_new</code>: The newly created knot vector with the added knot</li><li><code>knot_span_index</code>: The index such that <code>knots_all[knot_span_index] ≤ knot_new &lt; knots_all[knot_span_index + 1]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement.jl#L90-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.insert_knot-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, AbstractFloat}} where {Tv, Ti}" href="#SplineGrids.insert_knot-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, AbstractFloat}} where {Tv, Ti}"><code>SplineGrids.insert_knot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_knot(
    spline_dimension::SplineDimension{Tv, Ti},
    knot_new::AbstractFloat;
    recompute_sample_indices::Bool = true,
    evaluate::Bool = true)::Tuple{
        SplineDimension{Tv, Ti},
        RefinementMatrix{Tv, Ti}
    } where {Tv, Ti}</code></pre><p>Create a new spline dimension whose knot vector has the new knot with multiplicity 1.</p><p><strong>Inputs</strong></p><ul><li><code>spline_dimension</code>: The spline dimension the new knot will be added to</li><li><code>knot_new</code>: The value of the new knot</li><li><code>recompute_sample_indices</code>: Whether the indices of the sample points should be recomputed after the knot insertion. Defaults to <code>true</code>.</li><li><code>evaluate</code>: Whether the spline dimension should be evaluated after the knot insertion. Defaults to <code>true</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>spline_dimension_new</code>: The newly created spline dimension with the same underlying memory except for the new knot vector.</li><li><code>refinement_matrix</code>: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement.jl#L135-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.insert_knot-Union{Tuple{A}, Tuple{A, Integer, AbstractFloat}} where A&lt;:SplineGrids.AbstractSplineGrid" href="#SplineGrids.insert_knot-Union{Tuple{A}, Tuple{A, Integer, AbstractFloat}} where A&lt;:SplineGrids.AbstractSplineGrid"><code>SplineGrids.insert_knot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_knot(
    spline_grid::A,
    dim_refinement::Integer,
    knot_new::AbstractFloat;
    evaluate_spline_dimension::Bool = true)::Tuple{A, RefinementMatrix} where {A &lt;: AbstractSplineGrid}</code></pre><p>Create a new spline grid where a new knot is added to the knot vector underlying the indicated spline dimension.</p><p><strong>Inputs</strong></p><ul><li><code>spline_grid</code>: The spline grid to which the new knot will be added</li><li><code>knot_new</code>: The value of the knot to be added</li><li><code>dim_refinement</code>: The index of the spline dimension to which the knot will be added</li><li><code>evaluate_spline_dimension</code>: Whether the spline dimension to which the knot is added should be evaluated. Defaults to <code>true</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>spline_grid_new</code>: The newly created spline grid with all the same underlying memory except for the updated knot vector and the control points.</li><li><code>refinement_matrix</code>: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion for the knot insertion dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement.jl#L188-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.refine-Union{Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#SplineGrids.refine-Union{Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>SplineGrids.refine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine(
    spline_dimension::SplineDimension{Tv, Ti};
    knots_new::Union{Vector{&lt;:AbstractFloat}, Nothing} = nothing)::Tuple{SplineDimension{Tv, Ti}, RefinementMatrix{Tv, Ti}} where {Tv, Ti}</code></pre><p>Create a new spline dimension with multiple knots added to the underlying knot vector.</p><p><strong>Inputs</strong></p><ul><li><code>spline_dimension</code>: The spline dimension the new knots will be added to</li><li><code>knots_new</code>: The vector of knots that will be added. Defaults to the midpoints of the knot spans of the vector underlying the spline dimension.</li></ul><p><strong>Outputs</strong></p><ul><li><code>spline_dimension_new</code>: The newly created spline dimension with the same underlying memory except for the new knot vector.</li><li><code>refinement_matrix</code>: The sparse matrix which expresses the basis functions from before the refinement in terms of the basis functions after the refinement.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement.jl#L237-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.refine-Union{Tuple{A}, Tuple{A, Integer}} where A&lt;:SplineGrids.AbstractSplineGrid" href="#SplineGrids.refine-Union{Tuple{A}, Tuple{A, Integer}} where A&lt;:SplineGrids.AbstractSplineGrid"><code>SplineGrids.refine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine(
    spline_grid::A,
    dim_refinement::Integer;
    knots_new::Union{AbstractVector{&lt;:AbstractFloat}, Nothing} = nothing)::Tuple{A, RefinementMatrix} where {A &lt;: AbstractSplineGrid}</code></pre><p>Create a new spline grid where multiple knots are added to the knot vector underlying the indicated spline dimension.</p><p><strong>Inputs</strong></p><ul><li><code>spline_grid</code>: The spline grid from which one of the knot vectors will be refined</li><li><code>dim_refinement</code>: The index of the spline dimension whose knot vector will be refined</li><li><code>knots_new</code>: The knots that will be added. Defaults to <code>nothing</code>, which internally is translated to all midpoints of the non-trivial knot spans of the knot vector that will be refined.</li></ul><p><strong>Outputs</strong></p><ul><li><code>spline_grid_new</code>: The newly created spline grid with all the same underlying memory except for the updated knot vector and the control points.</li><li><code>refinement_matrix</code>: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion for the knot insertion dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement.jl#L286-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.refine-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false, Tv, Ti}, SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, Integer, RefinementMatrix{Tv, Ti}}} where {Nin, Nout, Tv, Ti}" href="#SplineGrids.refine-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false, Tv, Ti}, SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, Integer, RefinementMatrix{Tv, Ti}}} where {Nin, Nout, Tv, Ti}"><code>SplineGrids.refine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine(
    spline_grid::AbstractSplineGrid{Nin, Nout, false, Tv, Ti},
    spline_dimension_new::SplineDimension{Tv, Ti},
    dim_refinement::Integer,
    refinement_matrix::RefinementMatrix{Tv, Ti} where {Nin, Nout, Tv, Ti}</code></pre><p>Update the spline grid with a refined spline dimension in the specified dimension with the associated refinement matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement.jl#L332-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.activate_local_refinement!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{LocallyRefinedControlPoints{Nin, Nout, Tv, Ti, V, L} where {V&lt;:(AbstractArray{Tv}), L&lt;:(LocalRefinement{Nin, Nout, Tv, Ti, R, I, D} where {R&lt;:RefinementMatrix, I&lt;:AbstractMatrix{Ti}, D&lt;:AbstractMatrix{Tv}})}, AbstractMatrix{Ti}}} where {Nin, Nout, Tv, Ti}" href="#SplineGrids.activate_local_refinement!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{LocallyRefinedControlPoints{Nin, Nout, Tv, Ti, V, L} where {V&lt;:(AbstractArray{Tv}), L&lt;:(LocalRefinement{Nin, Nout, Tv, Ti, R, I, D} where {R&lt;:RefinementMatrix, I&lt;:AbstractMatrix{Ti}, D&lt;:AbstractMatrix{Tv}})}, AbstractMatrix{Ti}}} where {Nin, Nout, Tv, Ti}"><code>SplineGrids.activate_local_refinement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a refinement step (by default the last refinement), add new control points that overwrite the result from the refinement matrix. These new values are chosen such that the spline geometry does not change.</p><p><strong>Inputs</strong></p><ul><li><code>control_points</code>: The locally refined control points where new control points will be activated</li><li><code>refinement_indices</code>: The indices in the control point grid at the <code>refinement_index</code> level which will be overwritten</li><li><code>refinement_index</code>: The index of the refinement after which new control points will be activated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L458-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.activate_local_refinement!-Tuple{SplineGrids.AbstractSplineGrid, Vararg{Any}}" href="#SplineGrids.activate_local_refinement!-Tuple{SplineGrids.AbstractSplineGrid, Vararg{Any}}"><code>SplineGrids.activate_local_refinement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Convenience wrapper of <code>activate_local_refinement!</code> for a spline grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L518-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.activate_local_control_point_range!" href="#SplineGrids.activate_local_control_point_range!"><code>SplineGrids.activate_local_control_point_range!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Instead of supplying explicit indices of the control points for local refinement activation, supply a range of indices per dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L527-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.error_informed_local_refinement!" href="#SplineGrids.error_informed_local_refinement!"><code>SplineGrids.error_informed_local_refinement!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">error_informed_local_refinement!(
    spline_grid::AbstractSplineGrid{Nin, Nout, HasWeights, Tv, Ti},
    error::AbstractArray;
    threshold::Union{Number, Nothing} = nothing
    )::Nothing where {Nin, Nout, HasWeights, Tv, Ti}</code></pre><p>Refine the last level of the locally refined spline grid informed by the <code>error</code> array which has the same shape as <code>spline_grid.eval</code>. This is done by:</p><ul><li>mapping the error back onto the control points by using the adjoint of the refinement matrices multiplication</li><li>summing over the output dimensions to obtain a single number per control point stored in <code>control_grid_error</code></li><li>activating each control point whose value is bigger than <code>threshold</code></li></ul><p><code>threshold</code> can be explicitly provided but by default it is given by the mean of <code>control_grid_error</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L541-L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.deactivate_overwritten_control_points!-Tuple{LocallyRefinedControlPoints}" href="#SplineGrids.deactivate_overwritten_control_points!-Tuple{LocallyRefinedControlPoints}"><code>SplineGrids.deactivate_overwritten_control_points!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Perform <code>deactivate_control_points</code> for every refinement level except the last one in reverse order. For more details see <code>deactivate_overwritten_control_points!(::LocallyRefinedControlPoints, ::Integer)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L584-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.deactivate_overwritten_control_points!-Tuple{LocallyRefinedControlPoints, Integer}" href="#SplineGrids.deactivate_overwritten_control_points!-Tuple{LocallyRefinedControlPoints, Integer}"><code>SplineGrids.deactivate_overwritten_control_points!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deactivate_overwritten_control_points!(
    control_points::LocallyRefinedControlPoints,
    local_refinement_level::Integer)::Nothing</code></pre><p>Deactivate control points whose effect is completely overwritten. The procedure works as follows:</p><p>The &#39;forward&#39; computation to process local refinement is as follows:</p><p><code>B = (O₂ ∘ L ∘ O₁)(A)</code>,</p><p>where:</p><ul><li><code>A</code> is the control point grid at <code>local_refinement_level</code></li><li><code>B</code> is the control point grid at <code>local_refinement_level + 1</code></li><li><code>O₁</code> is the overwriting operation of the active control points at <code>local_refinement_level</code></li><li><code>L</code> is the linear operation consisting of multiplying by refinement matrices along specified dimensions</li><li><code>O₂</code> is the overwriting operation of the active control points at <code>local_refinement_level + 1</code></li></ul><p>To figure out whether for any overwriting element of <code>O₁</code> its effect is still present in the final array, we perform the following computation:</p><p><code>A = (L* ∘ O₂)(B)</code>,</p><p>where:</p><ul><li><code>B</code> is initialized with a special number <code>Flag</code>, which is a simple wrapper of a Boolean effectively saying whether this number is relevant or not. <code>B</code> is initialized with all <code>Flag(true)</code></li><li>The overwriting values of <code>O₂</code> are initialized with all <code>Flag(false)</code></li><li><code>L*</code> is the adjoint version of <code>L</code></li></ul><p>After this computation we can read of in <code>A</code> at the overwriting locations of <code>O₁</code> whether each number is still having an effect on <code>B</code> or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L594-L627">source</a></section></article><h1 id="Structs"><a class="docs-heading-anchor" href="#Structs">Structs</a><a id="Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Structs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.KnotVector" href="#SplineGrids.KnotVector"><code>SplineGrids.KnotVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KnotVector(knots, multiplicities)</code></pre><p>Defines a knot vector.</p><p><strong>Arguments</strong></p><ul><li><code>knot_values</code>: The values in the knot vector. Must be strictly increasing.</li><li><code>multiplicities</code>: The multiplicity of each knot in <code>knots</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/knot_vector.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.SplineDimension" href="#SplineGrids.SplineDimension"><code>SplineGrids.SplineDimension</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineDimension(
    degree, 
    max_derivative_order, 
    knot_vector, 
    sample_points, 
    sample_indices, 
    eval, 
    eval_prev)</code></pre><p>Defines the set of basis functions for a single dimension, and how it is sampled.</p><p><strong>Arguments</strong></p><ul><li><code>degree</code>: The degree of the piecewise polynomial basis functions.</li><li><code>max_derivative_order</code>: The maximum derivative order of the basis functions that will be computed.</li><li><code>knot_vector</code>: The knot vector on which the basis functions are defined.</li><li><code>sample_points</code>: The points in the domain of the basis functions where they are sampled. Must</li><li>lie within the boundaries of the knot vector.</li><li><code>sample_indices</code>: The indices <code>i</code> of the sample points <code>t</code> in the knot vector such that <code>knot_vector.knots[i] ≤ t &lt; knot_vector.knots[i + 1]</code>`</li><li><code>eval</code>: An array of shape <code>(length(sample_points), degree + 1, max_derivative + 1)</code>, with per sample point the values of those basis functions</li><li><code>eval_prev</code>: Helper array for intermediate results in the basis function computations whose support the sample point is in, and the derivatives if requested.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_dimension.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.RefinementMatrix" href="#SplineGrids.RefinementMatrix"><code>SplineGrids.RefinementMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefinementMatrix(m, n, row_pointer, column_start, nzval)</code></pre><p>The refinement matrix is a sparse matrix encoding for matrices which:</p><ol><li>Have consecutive non-zeros in all rows and columns</li><li>Have at least 1 nonzero in every row and column</li></ol><p>The non-zeros are stored in a dense vector per row.</p><p><strong>Fields</strong></p><ul><li><code>m</code>: The number of rows of the matrix</li><li><code>n</code>: The number of columns of the matrix</li><li><code>row_pointer</code>: <code>row_pointer[i]</code> indicates where in <code>nzval</code> the data for the <code>i</code>-th row starts</li><li><code>column_start</code>: <code>column_start[i]</code> indicates at which column the first nonzero for the <code>i</code>-th row is</li><li><code>nzval</code>: The nonzero values in the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/refinement_matrix.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.DefaultControlPoints" href="#SplineGrids.DefaultControlPoints"><code>SplineGrids.DefaultControlPoints</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DefaultControlPoints(control_points)</code></pre><p>A thin wrapper around an array of control point values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.LocalRefinement" href="#SplineGrids.LocalRefinement"><code>SplineGrids.LocalRefinement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalRefinement(
    dims_refinement,
    refinement_matrices,
    refinement_indices,
    refinement_values)</code></pre><p>The data for performing a local refinement; one or more refinement matrices and the to be overwritten control point values after multiplication with the refinement matrices along the specified dimensions.</p><p><strong>Fields</strong></p><ul><li><code>dims_refinement</code>: The dimensions along which will be refined</li><li><code>refinement_matrices</code>: The matrices that perform the refinement</li><li><code>refinement_indices</code>: The indices of the control points that will be overwritten after the refinement</li><li><code>refinement_values</code>: The new values of the control points that will be rewritten after refinement</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L59-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.LocallyRefinedControlPoints" href="#SplineGrids.LocallyRefinedControlPoints"><code>SplineGrids.LocallyRefinedControlPoints</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocallyRefinedControlPoints(
    control_points_base,
    control_points_refined,
    local_refinements)</code></pre><p>All data required to perform multiple refinement steps and overwriting control point values along the way, yielding a Truncated Hierarchical Basis (THB) spline.</p><p><strong>Fields</strong></p><ul><li><code>control_points_base</code>: The densely defined control points at the basis of the hierarchy</li><li><code>control_points_refined</code>: The intermediate and final control point arrays after applying the local refinements</li><li><code>local_refinements</code>: Data for local refinement for each step in the hierarchy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L156-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.SplineGrid" href="#SplineGrids.SplineGrid"><code>SplineGrids.SplineGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineGrid(
    spline_dimensions,
    control_points,
    weights,
    eval)</code></pre><p>The SplineGrid is the central object of the <code>SplineGrids.jl</code> package, containing all information to evaluate the defined spline on the defined grid.</p><p><strong>Fields</strong></p><ul><li><code>spline_dimensions</code>: A SplineDimension per dimension of the spline, containing data to evaluate basis functions.</li><li><code>control points</code>: The points that define the shape of the spline, and in how many dimensions it is embedded.</li><li><code>weights</code>: Control point weights to define NURBS.</li><li><code>eval</code>: The array where the evaluated spline grid is stored.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_grid.jl#L1-L18">source</a></section></article><h1 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.decompress" href="#SplineGrids.decompress"><code>SplineGrids.decompress</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decompress(
    spline_dimension::SplineDimension{Tv}; derivative_order::Integer = 0) where {Tv}</code></pre><p>Transform <code>spline_dimension.eval</code> into a matrix of shape <code>(n_sample_points, n_points - degree - 1)</code> which explicitly gives the value for each basis function at each sample point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/spline_dimension.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.get_n_control_points" href="#SplineGrids.get_n_control_points"><code>SplineGrids.get_n_control_points</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the number of control points within the control point object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L276-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.add_default_local_refinement" href="#SplineGrids.add_default_local_refinement"><code>SplineGrids.add_default_local_refinement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_default_local_refinement(spline_grid)</code></pre><p>Refine in the default way in every dimension, i.e. bisecting every non-trivial knot span. Yields a spline grid with a <code>LocallyRefinedControlPoints</code> object for the <code>control_points</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/dad7a5928c58468e58450407a6fd480e1577e4d3/src/control_points.jl#L358-L363">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples_optics/">« Optimizing a lens surface</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 27 January 2025 15:36">Monday 27 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

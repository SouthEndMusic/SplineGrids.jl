<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · SplineGrids.jl</title><meta name="title" content="Manual · SplineGrids.jl"/><meta property="og:title" content="Manual · SplineGrids.jl"/><meta property="twitter:title" content="Manual · SplineGrids.jl"/><meta name="description" content="Documentation for SplineGrids.jl."/><meta property="og:description" content="Documentation for SplineGrids.jl."/><meta property="twitter:description" content="Documentation for SplineGrids.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SplineGrids.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SplineGrids.jl</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory_refinement/">Refinement</a></li><li><a class="tocitem" href="../theory_local_refinement/">Local refinement (THB-splines)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_dimensions/">Dimensionality</a></li><li><a class="tocitem" href="../examples_nurbs/">NURBS</a></li><li><a class="tocitem" href="../examples_derivatives/">Derivatives</a></li><li><a class="tocitem" href="../examples_linear_fitting/">Linear fitting</a></li><li><a class="tocitem" href="../examples_enzyme/">Control point derivatives with Enzyme</a></li></ul></li><li><span class="tocitem">Advanced examples</span><ul><li><a class="tocitem" href="../examples_pde/">Solving a PDE</a></li><li><a class="tocitem" href="../examples_optics/">Optimizing a lens surface</a></li></ul></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li class="toplevel"><a class="tocitem" href="#Geometric-operations"><span>Geometric operations</span></a></li><li class="toplevel"><a class="tocitem" href="#Structs"><span>Structs</span></a></li><li class="toplevel"><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SouthEndMusic/SplineGrids.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/master/docs/src/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.KnotVector-Tuple{Integer, Integer}" href="#SplineGrids.KnotVector-Tuple{Integer, Integer}"><code>SplineGrids.KnotVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KnotVector(
    n_basis_functions::Integer, 
    degree::Integer; 
    extent::Tuple{Number, Number} = (0,1), 
    distribution::Symbol = :equispaced)</code></pre><p>Construct a clamped knot vector, i.e. the multiplicity of the first and last knot is degree + 1 and the other multiplicities are 1.</p><p><strong>Arguments</strong></p><ul><li><code>n_basis_functions</code>: The number of basis functions that will be defined on this knot vector</li><li><code>degree</code>: The degree of the basis functions that will be defined on this knot vector</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>extent</code>: A tuple (t<em>min, t</em>max) defining the extend of the knot vector</li><li><code>distribution</code>: The distribution of the internal knots. The options are :equispaced or :random</li><li><code>backend</code>: The KernelAbstractions backend of the arrays in the object. Defaults to <code>CPU()</code>.</li><li><code>float_type</code>: The type of all floating point arrays. Defaults to <code>Float32</code>.</li><li><code>int_type</code>: The type of all integer arrays. Defaults to <code>Int32</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/knot_vector.jl#L52-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.SplineDimension-Tuple{Integer, Integer, Integer}" href="#SplineGrids.SplineDimension-Tuple{Integer, Integer, Integer}"><code>SplineGrids.SplineDimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineDimension(
    n_basis_functions::Integer,
    degree::Integer,
    n_sample_points::Integer;
    max_derivative_order::Integer = 0,
    knot_vector::Union{Nothing, KnotVector{Tv, Ti}} = nothing,
    backend::Backend = CPU(),
    float_type::Type{Tv} = Float32,
    int_type::Type{Ti} = Int32,
    kwargs...)::SplineDimension where {Tv &lt;: AbstractFloat, Ti &lt;: Integer}</code></pre><p>Constructor for a SplineDimension. Optionally a <code>knot_vector</code> kwarg can be passed, otherwise a default knot vector is generated. For now by default the sample points are evenly spaced on the extent of the knot vector. Key word arguments are passed to the KnotVector constructor.</p><p><strong>Inputs</strong></p><ul><li><code>n_basis_functions</code>: The number of basis functions of this spline dimension</li><li><code>degree</code>: The degree of the basis functions of this spline dimension</li><li><code>n_sample_points</code>: The number of points at which the domain of the basis functions will be sampled</li><li><code>max_derivative_order</code>: The maximum derivative order of the basis functions that will be computed in <code>evaluate!</code>. Defaults to <code>0</code>. <code>knot_vector</code>: A knot vector on which the basis functions will be defined. Defaults to <code>nothing</code>, which means that a default clamped/open equally spaced knot vector will be defined.</li><li><code>backend</code>: The KernelAbstractions backend of the arrays in the object. Defaults to <code>CPU()</code>. NOTE: If a knot vector is supplied, its backend takes precedence.</li><li><code>float_type</code>: The type of all floating point arrays. Defaults to <code>Float32</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_dimension.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.SplineGrid-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nin}, Tuple{NTuple{Nin, var&quot;#s76&quot;} where var&quot;#s76&quot;&lt;:(SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}), Integer}} where {Nin, Tv, Ti}" href="#SplineGrids.SplineGrid-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nin}, Tuple{NTuple{Nin, var&quot;#s76&quot;} where var&quot;#s76&quot;&lt;:(SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}), Integer}} where {Nin, Tv, Ti}"><code>SplineGrids.SplineGrid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineGrid(spline_dimensions::NTuple{Nin, &lt;:SplineDimension{Tv, Ti}}, Nout::Integer)::SplineGrid{Nin, Tv, Ti} where {Nin, Tv, Ti}</code></pre><p>Define a <code>SplineGrid</code> from an NTuple of spline dimensions and the number of output dimensions.</p><p><strong>Inputs</strong></p><ul><li><code>spline_dimensions</code>: an NTuple of spline dimensions</li><li><code>Nout</code>: The number of output dimensions. I.e. the control points and thus the spline live in ℝ^Nout.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_grid.jl#L84-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.rmeye-Tuple{Integer}" href="#SplineGrids.rmeye-Tuple{Integer}"><code>SplineGrids.rmeye</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rmeye(
    n::Integer;
    backend::Backend = CPU(),
    float_type::Type{Tv} = Float32,
    int_type::Type{Ti} = Int)::RefinementMatrix{Tv, Ti} where {Tv, Ti &lt;: Integer}</code></pre><p>Construct an identity refinement matrix.</p><p><strong>Input</strong></p><ul><li><code>n</code>: The size of the identity matrix is n×n</li><li><code>backend</code>: The KernelAbstractions backend of the matrix data</li><li><code>float_type</code>: The value type of the matrix data</li><li><code>int_type</code>: The integer type of the matrix data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement_matrix.jl#L446-L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.RefinementMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, Integer, Any}} where {Tv, Ti&lt;:Integer}" href="#SplineGrids.RefinementMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, Integer, Any}} where {Tv, Ti&lt;:Integer}"><code>SplineGrids.RefinementMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefinementMatrix(
    spline_dimension::SplineDimension{Tv, Ti},
    knot_span_index::Integer,
    knot_new
    )::RefinementMatrix{Tv, Ti} where {Tv, Ti &lt;: Integer}</code></pre><p>Build a refinement matrix per row given a knot vector and a to be added new knot.</p><p><strong>Inputs</strong></p><ul><li><code>spline_dimension</code>: The spline dimension whose knot vector the new knot is to be added to</li><li><code>knot_span_index</code>: The index such that <code>knots_all[knot_span_index] ≤ knot_new &lt; knots_all[knot_span_index + 1]</code></li><li><code>knot_new</code>: The value of the new knot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement.jl#L38-L52">source</a></section></article><h1 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate!-Tuple{SplineDimension}" href="#SplineGrids.evaluate!-Tuple{SplineDimension}"><code>SplineGrids.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate!(spline_dimension)</code></pre><p>Per sample point, get the value of the <code>spline_dimension.degree + 1</code> basis functions that have a non-zero value for that sample point. This is based on the Cox-de Boor recursion formula.</p><p>The l-th sample point <code>t</code> has sample index <code>i</code>, meaning that <code>t ∈ [tᵢ, tᵢ₊₁)</code>. Therefore <code>Bᵢ₀(t) = 1, Bⱼ₀(t) = 0 for j ≠ i</code>. For degree <code>k</code>, <code>t</code> is in the domain of <code>Bⱼₖ</code> which is <code>[tⱼ, tⱼ₊ₖ₊₁)</code>, for <code>j = i - k, ..., i</code>.</p><p><strong>Arguments</strong></p><ul><li><code>spline_dimension</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_dimension.jl#L217-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false}}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout}" href="#SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false}}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout}"><code>SplineGrids.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate!(spline_grid::SplineGrid{Nin};
    derivative_order::NTuple{Nin, &lt;:Integer} = ntuple(_ -&gt; 0, Nin),
    control_points::AbstractArray = spline_grid.control_points,
    eval::AbstractArray = spline_grid.eval)</code></pre><p>Evaluate the spline grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a linear combination of control with basis function products as coefficients.</p><p>Uses the <code>control_points</code> and <code>eval</code> arrays from the <code>spline_grid</code> by default, but different arrays can be specified as a convenience for optimization algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_grid.jl#L163-L175">source</a></section><section><div><pre><code class="language-julia hljs">evaluate!(
    spline_grid::AbstractNURBSGrid{Nin};
    control_points::AbstractArray = spline_grid.control_points,
    weights::AbstractArray = spline_grid.weights,
    eval::AbstractArray = spline_grid.eval)::Nothing where {Nin}</code></pre><p>Evaluate the NURBS grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a weighted linear combination of control points with rational functions as coefficients.</p><p>Uses the <code>control_points</code>, <code>weights</code> and <code>eval</code> arrays from the <code>spline_grid</code> by default, but different arrays can be specified as a convenience for optimization algorithms.</p><p>NOTE: At the moment computing derivatives of NURBS grids is not supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/nurbs_grid.jl#L88-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, true, Tv, Ti} where {Nout, Tv, Ti}}, Tuple{Nin}} where Nin" href="#SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, true, Tv, Ti} where {Nout, Tv, Ti}}, Tuple{Nin}} where Nin"><code>SplineGrids.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate!(spline_grid::SplineGrid{Nin};
    derivative_order::NTuple{Nin, &lt;:Integer} = ntuple(_ -&gt; 0, Nin),
    control_points::AbstractArray = spline_grid.control_points,
    eval::AbstractArray = spline_grid.eval)</code></pre><p>Evaluate the spline grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a linear combination of control with basis function products as coefficients.</p><p>Uses the <code>control_points</code> and <code>eval</code> arrays from the <code>spline_grid</code> by default, but different arrays can be specified as a convenience for optimization algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_grid.jl#L163-L175">source</a></section><section><div><pre><code class="language-julia hljs">evaluate!(
    spline_grid::AbstractNURBSGrid{Nin};
    control_points::AbstractArray = spline_grid.control_points,
    weights::AbstractArray = spline_grid.weights,
    eval::AbstractArray = spline_grid.eval)::Nothing where {Nin}</code></pre><p>Evaluate the NURBS grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a weighted linear combination of control points with rational functions as coefficients.</p><p>Uses the <code>control_points</code>, <code>weights</code> and <code>eval</code> arrays from the <code>spline_grid</code> by default, but different arrays can be specified as a convenience for optimization algorithms.</p><p>NOTE: At the moment computing derivatives of NURBS grids is not supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/nurbs_grid.jl#L88-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate_adjoint!-Union{Tuple{SplineGrid{Nin, Nout, Tv, Ti, S, C, D, W, E, I} where {Nout, Tv&lt;:AbstractFloat, Ti&lt;:Integer, S&lt;:(SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}), C&lt;:SplineGrids.AbstractControlPoints{Nin, Nout, Tv}, D&lt;:Union{Nothing, AbstractArray{Tv, Nin}}, W&lt;:Union{Nothing, AbstractArray{Tv, Nin}}, E&lt;:(AbstractArray{Tv}), I&lt;:AbstractArray{Ti, Nin}}}, Tuple{Nin}} where Nin" href="#SplineGrids.evaluate_adjoint!-Union{Tuple{SplineGrid{Nin, Nout, Tv, Ti, S, C, D, W, E, I} where {Nout, Tv&lt;:AbstractFloat, Ti&lt;:Integer, S&lt;:(SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}), C&lt;:SplineGrids.AbstractControlPoints{Nin, Nout, Tv}, D&lt;:Union{Nothing, AbstractArray{Tv, Nin}}, W&lt;:Union{Nothing, AbstractArray{Tv, Nin}}, E&lt;:(AbstractArray{Tv}), I&lt;:AbstractArray{Ti, Nin}}}, Tuple{Nin}} where Nin"><code>SplineGrids.evaluate_adjoint!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate_adjoint!(spline_grid::SplineGrid{Nin, Nout, false};
    derivative_order::NTuple{Nin, &lt;:Integer} = ntuple(_ -&gt; 0, Nin),
    control_points::AbstractArray = spline_grid.control_points,
    eval::AbstractArray = spline_grid.eval)::Nothing where {Nin}</code></pre><p>evaluate the adjoint of the linear mapping <code>control_points -&gt; eval</code>. This is a computation of the form <code>eval -&gt; control_points</code>. If we write <code>evaluate!(spline_grid)</code> as a matrix vector multiplication <code>eval = M * control_points</code>, Then the adjoint is given by <code>v -&gt; M&#39; * v</code>. This mapping is used in fitting algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_grid.jl#L248-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.mult!-Union{Tuple{A}, Tuple{Tv}, Tuple{A, RefinementMatrix{Tv}, A, Integer}} where {Tv, A&lt;:(AbstractArray{Tv})}" href="#SplineGrids.mult!-Union{Tuple{A}, Tuple{Tv}, Tuple{A, RefinementMatrix{Tv}, A, Integer}} where {Tv, A&lt;:(AbstractArray{Tv})}"><code>SplineGrids.mult!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mult!(
    Y::V,
    A::RefinementMatrix{Tv},
    B::V,
    dim_refinement::Integer)::Nothing where {Tv, V &lt;: AbstractArray{Tv}}</code></pre><p>Multiply each &#39;sub-vector&#39; of <code>control_points</code> along the refinement dimension by the refinement matrix in-place.</p><p><strong>Inputs</strong></p><ul><li><code>Y</code>: The target array of the multiplication</li><li><code>A</code>: The matrix each &#39;sub-vector&#39; of <code>B</code> will be multiplied by</li><li><code>B</code>: The array that will be multiplied by the refinement matrix</li><li><code>dim_refinement</code>: The dimension along which the refinement matrix multiplication will take place</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement_matrix.jl#L397-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.evaluate!-Tuple{LocallyRefinedControlPoints}" href="#SplineGrids.evaluate!-Tuple{LocallyRefinedControlPoints}"><code>SplineGrids.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluate the locally refined control points. For each local refinement, first apply the refinement matrix and then overwrite the desired control point values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L267-L270">source</a></section></article><h1 id="Geometric-operations"><a class="docs-heading-anchor" href="#Geometric-operations">Geometric operations</a><a id="Geometric-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-operations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.insert_knot-Tuple{KnotVector, AbstractFloat}" href="#SplineGrids.insert_knot-Tuple{KnotVector, AbstractFloat}"><code>SplineGrids.insert_knot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_knot(
knot_vector::KnotVector, 
knot_new::AbstractFloat)::Tuple{KnotVector, Integer}</code></pre><p>Create a new knot vector with the new knot of multiplicity 1.</p><p><strong>Inputs</strong></p><ul><li><code>knot_vector</code>: The knot vector object to which the knot will be added</li><li><code>knot_new</code>: The value of the new knot. Should not be part of the knot values already</li></ul><p><strong>Outputs</strong></p><ul><li><code>knot_vector_new</code>: The newly created knot vector with the added knot</li><li><code>knot_span_index</code>: The index such that <code>knots_all[knot_span_index] ≤ knot_new &lt; knots_all[knot_span_index + 1]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement.jl#L90-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.insert_knot-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, AbstractFloat}} where {Tv, Ti}" href="#SplineGrids.insert_knot-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, AbstractFloat}} where {Tv, Ti}"><code>SplineGrids.insert_knot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_knot(
    spline_dimension::SplineDimension{Tv, Ti},
    knot_new::AbstractFloat;
    recompute_sample_indices::Bool = true,
    evaluate::Bool = true)::Tuple{
        SplineDimension{Tv, Ti},
        RefinementMatrix{Tv, Ti}
    } where {Tv, Ti}</code></pre><p>Create a new spline dimension whose knot vector has the new knot with multiplicity 1.</p><p><strong>Inputs</strong></p><ul><li><code>spline_dimension</code>: The spline dimension the new knot will be added to</li><li><code>knot_new</code>: The value of the new knot</li><li><code>recompute_sample_indices</code>: Whether the indices of the sample points should be recomputed after the knot insertion. Defaults to <code>true</code>.</li><li><code>evaluate</code>: Whether the spline dimension should be evaluated after the knot insertion. Defaults to <code>true</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>spline_dimension_new</code>: The newly created spline dimension with the same underlying memory except for the new knot vector.</li><li><code>refinement_matrix</code>: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement.jl#L135-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.insert_knot-Union{Tuple{A}, Tuple{A, Integer, AbstractFloat}} where A&lt;:SplineGrids.AbstractSplineGrid" href="#SplineGrids.insert_knot-Union{Tuple{A}, Tuple{A, Integer, AbstractFloat}} where A&lt;:SplineGrids.AbstractSplineGrid"><code>SplineGrids.insert_knot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_knot(
    spline_grid::A,
    dim_refinement::Integer,
    knot_new::AbstractFloat;
    evaluate_spline_dimension::Bool = true,
    recompute_global_sample_indices = true)::Tuple{A, RefinementMatrix} where {A &lt;: AbstractSplineGrid}</code></pre><p>Create a new spline grid where a new knot is added to the knot vector underlying the indicated spline dimension.</p><p><strong>Inputs</strong></p><ul><li><code>spline_grid</code>: The spline grid to which the new knot will be added</li><li><code>knot_new</code>: The value of the knot to be added</li><li><code>dim_refinement</code>: The index of the spline dimension to which the knot will be added</li><li><code>evaluate_spline_dimension</code>: Whether the spline dimension to which the knot is added should be evaluated. Defaults to <code>true</code>.</li><li><code>recompute_global_sample_indices</code>: Whether the global sample indices should be recomputed after the knot insertion. Defaults to <code>true</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>spline_grid_new</code>: The newly created spline grid with all the same underlying memory except for the updated knot vector and the control points.</li><li><code>refinement_matrix</code>: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion for the knot insertion dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement.jl#L188-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.refine-Union{Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#SplineGrids.refine-Union{Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>SplineGrids.refine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine(
    spline_dimension::SplineDimension{Tv, Ti};
    knots_new::Union{Vector{&lt;:AbstractFloat}, Nothing} = nothing)::Tuple{SplineDimension{Tv, Ti}, RefinementMatrix{Tv, Ti}} where {Tv, Ti}</code></pre><p>Create a new spline dimension with multiple knots added to the underlying knot vector.</p><p><strong>Inputs</strong></p><ul><li><code>spline_dimension</code>: The spline dimension the new knots will be added to</li><li><code>knots_new</code>: The vector of knots that will be added. Defaults to the midpoints of the knot spans of the vector underlying the spline dimension.</li></ul><p><strong>Outputs</strong></p><ul><li><code>spline_dimension_new</code>: The newly created spline dimension with the same underlying memory except for the new knot vector.</li><li><code>refinement_matrix</code>: The sparse matrix which expresses the basis functions from before the refinement in terms of the basis functions after the refinement.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement.jl#L242-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.refine-Union{Tuple{A}, Tuple{A, Integer}} where A&lt;:SplineGrids.AbstractSplineGrid" href="#SplineGrids.refine-Union{Tuple{A}, Tuple{A, Integer}} where A&lt;:SplineGrids.AbstractSplineGrid"><code>SplineGrids.refine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine(
    spline_grid::A,
    dim_refinement::Integer;
    knots_new::Union{AbstractVector{&lt;:AbstractFloat}, Nothing} = nothing,
    recompute_global_sample_indices::Bool = true)::Tuple{A, RefinementMatrix} where {A &lt;: AbstractSplineGrid}</code></pre><p>Create a new spline grid where multiple knots are added to the knot vector underlying the indicated spline dimension.</p><p><strong>Inputs</strong></p><ul><li><code>spline_grid</code>: The spline grid from which one of the knot vectors will be refined</li><li><code>dim_refinement</code>: The index of the spline dimension whose knot vector will be refined</li><li><code>knots_new</code>: The knots that will be added. Defaults to <code>nothing</code>, which internally is translated to all midpoints of the non-trivial knot spans of the knot vector that will be refined.</li><li><code>recompute_global_sample_indices</code>: Whether the global sample indices should be recomputed after the knot refinement. Defaults to <code>true</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>spline_grid_new</code>: The newly created spline grid with all the same underlying memory except for the updated knot vector and the control points.</li><li><code>refinement_matrix</code>: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion for the knot insertion dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement.jl#L291-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.refine-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false, Tv, Ti}, SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, Integer, RefinementMatrix{Tv, Ti}}} where {Nin, Nout, Tv, Ti}" href="#SplineGrids.refine-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false, Tv, Ti}, SplineDimension{Tv, Ti, K, S, I, E} where {K&lt;:(KnotVector{Tv, Ti, K, M} where {K&lt;:AbstractVector{Tv}, M&lt;:AbstractVector{Ti}}), S&lt;:AbstractVector{Tv}, I&lt;:AbstractVector{Ti}, E&lt;:AbstractArray{Tv, 3}}, Integer, RefinementMatrix{Tv, Ti}}} where {Nin, Nout, Tv, Ti}"><code>SplineGrids.refine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine(
    spline_grid::AbstractSplineGrid{Nin, Nout, false, Tv, Ti},
    spline_dimension_new::SplineDimension{Tv, Ti},
    dim_refinement::Integer,
    refinement_matrix::RefinementMatrix{Tv, Ti};
    recompute_global_sample_indices::Bool = true) where {Nin, Nout, Tv, Ti}</code></pre><p>Update the spline grid with a refined spline dimension in the specified dimension with the associated refinement matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement.jl#L342-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.activate_local_refinement!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{LocallyRefinedControlPoints{Nin, Nout, Tv, Ti, V, L} where {V&lt;:(AbstractArray{Tv}), L&lt;:(LocalRefinement{Nin, Nout, Tv, Ti, R, I, D} where {R&lt;:RefinementMatrix, I&lt;:AbstractMatrix{Ti}, D&lt;:AbstractMatrix{Tv}})}, AbstractMatrix{Ti}}} where {Nin, Nout, Tv, Ti}" href="#SplineGrids.activate_local_refinement!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{LocallyRefinedControlPoints{Nin, Nout, Tv, Ti, V, L} where {V&lt;:(AbstractArray{Tv}), L&lt;:(LocalRefinement{Nin, Nout, Tv, Ti, R, I, D} where {R&lt;:RefinementMatrix, I&lt;:AbstractMatrix{Ti}, D&lt;:AbstractMatrix{Tv}})}, AbstractMatrix{Ti}}} where {Nin, Nout, Tv, Ti}"><code>SplineGrids.activate_local_refinement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a refinement step (by default the last refinement), add new control points that overwrite the result from the refinement matrix. These new values are chosen such that the spline geometry does not change.</p><p><strong>Inputs</strong></p><ul><li><code>control_points</code>: The locally refined control points where new control points will be activated</li><li><code>refinement_indices</code>: The indices in the control point grid at the <code>refinement_index</code> level which will be overwritten</li><li><code>refinement_index</code>: The index of the refinement after which new control points will be activated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L424-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.activate_local_refinement!-Tuple{SplineGrids.AbstractSplineGrid, Vararg{Any}}" href="#SplineGrids.activate_local_refinement!-Tuple{SplineGrids.AbstractSplineGrid, Vararg{Any}}"><code>SplineGrids.activate_local_refinement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Convenience wrapper of <code>activate_local_refinement!</code> for a spline grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L484-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.activate_local_control_point_range!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{HasWeights}, Tuple{Nout}, Tuple{Nin}, Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, HasWeights, Tv, Ti}, Vararg{UnitRange}}} where {Nin, Nout, HasWeights, Tv, Ti}" href="#SplineGrids.activate_local_control_point_range!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{HasWeights}, Tuple{Nout}, Tuple{Nin}, Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, HasWeights, Tv, Ti}, Vararg{UnitRange}}} where {Nin, Nout, HasWeights, Tv, Ti}"><code>SplineGrids.activate_local_control_point_range!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Instead of supplying explicit indices of the control points for local refinement activation, supply a range of indices per dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L493-L496">source</a></section></article><h1 id="Structs"><a class="docs-heading-anchor" href="#Structs">Structs</a><a id="Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Structs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.KnotVector" href="#SplineGrids.KnotVector"><code>SplineGrids.KnotVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KnotVector(knots, multiplicities)</code></pre><p>Defines a knot vector.</p><p><strong>Arguments</strong></p><ul><li><code>knot_values</code>: The values in the knot vector. Must be strictly increasing.</li><li><code>multiplicities</code>: The multiplicity of each knot in <code>knots</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/knot_vector.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.SplineDimension" href="#SplineGrids.SplineDimension"><code>SplineGrids.SplineDimension</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineDimension(
    degree, 
    max_derivative_order, 
    knot_vector, 
    sample_points, 
    sample_indices, 
    eval, 
    eval_prev)</code></pre><p>Defines the set of basis functions for a single dimension, and how it is sampled.</p><p><strong>Arguments</strong></p><ul><li><code>degree</code>: The degree of the piecewise polynomial basis functions.</li><li><code>max_derivative_order</code>: The maximum derivative order of the basis functions that will be computed.</li><li><code>knot_vector</code>: The knot vector on which the basis functions are defined.</li><li><code>sample_points</code>: The points in the domain of the basis functions where they are sampled. Must</li><li>lie within the boundaries of the knot vector.</li><li><code>sample_indices</code>: The indices <code>i</code> of the sample points <code>t</code> in the knot vector such that <code>knot_vector.knots[i] ≤ t &lt; knot_vector.knots[i + 1]</code>`</li><li><code>eval</code>: An array of shape <code>(length(sample_points), degree + 1, max_derivative + 1)</code>, with per sample point the values of those basis functions</li><li><code>eval_prev</code>: Helper array for intermediate results in the basis function computations whose support the sample point is in, and the derivatives if requested.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_dimension.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.RefinementMatrix" href="#SplineGrids.RefinementMatrix"><code>SplineGrids.RefinementMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefinementMatrix(m, n, row_pointer, column_start, nzval)</code></pre><p>The refinement matrix is a sparse matrix encoding for matrices which:</p><ol><li>Have consecutive non-zeros in all rows and columns</li><li>Have at least 1 nonzero in every row and column</li></ol><p>The non-zeros are stored in a dense vector per row.</p><p><strong>Fields</strong></p><ul><li><code>m</code>: The number of rows of the matrix</li><li><code>n</code>: The number of columns of the matrix</li><li><code>row_pointer</code>: <code>row_pointer[i]</code> indicates where in <code>nzval</code> the data for the <code>i</code>-th row starts</li><li><code>column_start</code>: <code>column_start[i]</code> indicates at which column the first nonzero for the <code>i</code>-th row is</li><li><code>nzval</code>: The nonzero values in the matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/refinement_matrix.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.DefaultControlPoints" href="#SplineGrids.DefaultControlPoints"><code>SplineGrids.DefaultControlPoints</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DefaultControlPoints(control_points)</code></pre><p>A thin wrapper around an array of control point values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.LocalRefinement" href="#SplineGrids.LocalRefinement"><code>SplineGrids.LocalRefinement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalRefinement(
    dim_refinement,
    refinement_matrix,
    refinement_indices,
    refinement_values)</code></pre><p>The data for performing a local refinement.</p><p><strong>Fields</strong></p><ul><li><code>dim_refinement</code>: The dimension along which will be refined</li><li><code>refinement_matrix</code>: The matrix that performs the refinement</li><li><code>refinement_indices</code>: The indices of the control points that will be overwritten after the refinement</li><li><code>refinement_values</code>: The new values of the control points that will be rewritten after refinement</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L50-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.LocallyRefinedControlPoints" href="#SplineGrids.LocallyRefinedControlPoints"><code>SplineGrids.LocallyRefinedControlPoints</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocallyRefinedControlPoints(
    control_points_base,
    control_points_refined,
    local_refinements)</code></pre><p>All data required to perform multiple refinement steps and overwriting control point values along the way, yielding a Truncated Hierarchical Basis (THB) spline.</p><p><strong>Fields</strong></p><ul><li><code>control_points_base</code>: The densely defined control points at the basis of the hierarchy</li><li><code>control_points_refined</code>: The intermediate and final control point arrays after applying the local refinements</li><li><code>local_refinements</code>: Data for local refinement for each step in the hierarchy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L115-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.SplineGrid" href="#SplineGrids.SplineGrid"><code>SplineGrids.SplineGrid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineGrid(
    spline_dimensions,
    control_points,
    denominator,
    weights,
    eval,
    sample_indices,
    basis_function_products)</code></pre><p>The SplineGrid is the central object of the <code>SplineGrids.jl</code> package, containing all information to evaluate the defined spline on the defined grid.</p><p><strong>Fields</strong></p><ul><li><code>spline_dimensions</code>: A SplineDimension per dimension of the spline, containing data to evaluate basis functions.</li><li><code>control points</code>: The points that define the shape of the spline, and in how many dimensions it is embedded.</li><li><code>denominator</code>: An optional array of intermediate results to evaluate the denominator of NURBS.</li><li><code>weights</code>: Control point weights to define NURBS.</li><li><code>eval</code>: The array where the evaluated spline grid is stored.</li><li><code>sample_indices</code>: For each global sample point, the linear index in the <code>control_points</code> array before it is offset for a particular index in the control point kernel and output dimension.</li><li><code>basis_function_products</code>: An array of intermediate results for evaluating the spline grids, containing products of basis functions from the various spline dimensions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_grid.jl#L1-L26">source</a></section></article><h1 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.decompress" href="#SplineGrids.decompress"><code>SplineGrids.decompress</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decompress(
    spline_dimension::SplineDimension{Tv}; derivative_order::Integer = 0) where {Tv}</code></pre><p>Transform <code>spline_dimension.eval</code> into a matrix of shape <code>(n_sample_points, n_points - degree - 1)</code> which explicitly gives the value for each basis function at each sample point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/spline_dimension.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.setup_default_local_refinement" href="#SplineGrids.setup_default_local_refinement"><code>SplineGrids.setup_default_local_refinement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Set up a default refinement matrix for each input dimension in order (a default refinement matrix means bisecting each non-trivial knot span). After this, data can be added to <code>spline_grid.control_points &lt;: LocallyRefinedControlPoints</code> from the output <code>spline_grid</code> to achieve local refinement by overwriting control point values resulting from the refinement matrix multiplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L333-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.get_n_control_points-Union{Tuple{LocallyRefinedControlPoints{Nin, Nout, Tv, Ti, V, L} where {Nout, Tv&lt;:AbstractFloat, Ti&lt;:Integer, V&lt;:(AbstractArray{Tv}), L&lt;:(LocalRefinement{Nin, Nout, Tv, Ti, R, I, D} where {R&lt;:RefinementMatrix, I&lt;:AbstractMatrix{Ti}, D&lt;:AbstractMatrix{Tv}})}}, Tuple{Nin}} where Nin" href="#SplineGrids.get_n_control_points-Union{Tuple{LocallyRefinedControlPoints{Nin, Nout, Tv, Ti, V, L} where {Nout, Tv&lt;:AbstractFloat, Ti&lt;:Integer, V&lt;:(AbstractArray{Tv}), L&lt;:(LocalRefinement{Nin, Nout, Tv, Ti, R, I, D} where {R&lt;:RefinementMatrix, I&lt;:AbstractMatrix{Ti}, D&lt;:AbstractMatrix{Tv}})}}, Tuple{Nin}} where Nin"><code>SplineGrids.get_n_control_points</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the number of control points within the control point object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L222-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.setup_default_local_refinement-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false, Tv, Ti}}, Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout, Tv, Ti}" href="#SplineGrids.setup_default_local_refinement-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false, Tv, Ti}}, Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout, Tv, Ti}"><code>SplineGrids.setup_default_local_refinement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Set up a default refinement matrix for each input dimension in order (a default refinement matrix means bisecting each non-trivial knot span). After this, data can be added to <code>spline_grid.control_points &lt;: LocallyRefinedControlPoints</code> from the output <code>spline_grid</code> to achieve local refinement by overwriting control point values resulting from the refinement matrix multiplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L333-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SplineGrids.extend_default_local_refinement-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin}}, Tuple{Nin}} where Nin" href="#SplineGrids.extend_default_local_refinement-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin}}, Tuple{Nin}} where Nin"><code>SplineGrids.extend_default_local_refinement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extend default local refinement, that is: for a spline grid that already has locally refined control points, add default local refinement for each input dimension in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/d12de0202ad795f2510e4c9d21ad095a2d559197/src/control_points.jl#L373-L376">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples_optics/">« Optimizing a lens surface</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 16 January 2025 09:14">Thursday 16 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimizing a lens surface · SplineGrids.jl</title><meta name="title" content="Optimizing a lens surface · SplineGrids.jl"/><meta property="og:title" content="Optimizing a lens surface · SplineGrids.jl"/><meta property="twitter:title" content="Optimizing a lens surface · SplineGrids.jl"/><meta name="description" content="Documentation for SplineGrids.jl."/><meta property="og:description" content="Documentation for SplineGrids.jl."/><meta property="twitter:description" content="Documentation for SplineGrids.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SplineGrids.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SplineGrids.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_dimensions/">Dimensionality</a></li><li><a class="tocitem" href="../examples_derivatives/">Derivatives</a></li><li><a class="tocitem" href="../examples_linear_fitting/">Linear fitting</a></li><li><a class="tocitem" href="../examples_enzyme/">Control point derivatives with Enzyme</a></li></ul></li><li><span class="tocitem">Advanced examples</span><ul><li><a class="tocitem" href="../examples_pde/">Solving a PDE</a></li><li class="is-active"><a class="tocitem" href>Optimizing a lens surface</a><ul class="internal"><li><a class="tocitem" href="#Differentiable-ray-tracing-kernel"><span>Differentiable ray tracing kernel</span></a></li><li><a class="tocitem" href="#Calling-the-ray-tracing-kernel"><span>Calling the ray tracing kernel</span></a></li><li><a class="tocitem" href="#Tracing-the-first-rays"><span>Tracing the first rays</span></a></li><li><a class="tocitem" href="#Defining-the-target-distribution"><span>Defining the target distribution</span></a></li><li><a class="tocitem" href="#The-loss-function"><span>The loss function</span></a></li><li><a class="tocitem" href="#Gradients-w.r.t.-control-points"><span>Gradients w.r.t. control points</span></a></li><li><a class="tocitem" href="#Optimizing-the-surface"><span>Optimizing the surface</span></a></li><li><a class="tocitem" href="#Viewing-the-optimization-result"><span>Viewing the optimization result</span></a></li><li><a class="tocitem" href="#A-peek-into-upcoming-features"><span>A peek into upcoming features</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../manual/">Manual</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced examples</a></li><li class="is-active"><a href>Optimizing a lens surface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimizing a lens surface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SouthEndMusic/SplineGrids.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/master/docs/src/examples_optics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lens-geometry-optimization-example"><a class="docs-heading-anchor" href="#Lens-geometry-optimization-example">Lens geometry optimization example</a><a id="Lens-geometry-optimization-example-1"></a><a class="docs-heading-anchor-permalink" href="#Lens-geometry-optimization-example" title="Permalink"></a></h1><p>In this section we optimize the surface of a lens to yield a target irradiance distribution on a screen. This process is called <em>caustic design</em>. Below a schematic of the simulated setup is shown.</p><img src="50282e88.png" alt="Example block output"/><h2 id="Differentiable-ray-tracing-kernel"><a class="docs-heading-anchor" href="#Differentiable-ray-tracing-kernel">Differentiable ray tracing kernel</a><a id="Differentiable-ray-tracing-kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Differentiable-ray-tracing-kernel" title="Permalink"></a></h2><p>Here we define a kernel which computes for each sample point on the surface:</p><ul><li>at which direction a ray leaves that point by Snell&#39;s law;</li><li>where that ray intersects the detector screen;</li><li>What the contributions of that ray to the pixel values are.</li></ul><p>The contribution of the ray is smeared out over multiple pixels in a smooth way to make the rendering differentiable.</p><pre><code class="language-julia hljs">using KernelAbstractions
using Atomix

# Kernel function for computing the contribution of a ray intersection to the
# pixels close to the intersection.
function F(x, x0, w)
    if x &lt; x0 - w
        -one(x) / 2
    elseif x &gt; x0 + w
        one(x) / 2
    else
        x_transformed = (x - x0) / w
        (sin(π * x_transformed) / π + x_transformed) / 2
    end
end

@kernel function ray_tracing_kernel(
    render,
    @Const(u),
    @Const(∂₁u),
    @Const(∂₂u),
    @Const(x),
    @Const(y),
    r,
    z_screen,
    screen_size,
    ray_kernel_size,
)

    I = @index(Global, Cartesian)

    u_I = u[I]
    ∂₁u_I = ∂₁u[I]
    ∂₂u_I = ∂₂u[I]

    x_I = x[I[1]]
    y_I = y[I[2]]

    # x direction tangent vector: (1, 0, ∂₁u[I])
    # y direction tangent vector: (0, 1, ∂₂u[I])
    # -cross product (surface normal): n = (∂₁u[I], ∂₂u[I], -1) / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)
    # light vector: ℓ = (0, 0, 1)
    # Snell&#39;s law (vector form):
    # c = -⟨n, ℓ⟩ = 1 / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)
    # v = r * (0, 0, 1) + (r * c - √(1 - r^2 * (1 - c^2))) * (∂₁u[I], ∂₂u[I], -1) / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)

    cross_product_norm = √(1 + ∂₁u_I^2 + ∂₂u_I^2)
    c = 1 / cross_product_norm
    sqrt_arg = 1 - r^2 * (1 - c^2)
    if sqrt_arg &gt;= 0
        normal_vector_coef = (r * c - √(1 - r^2 * (1 - c^2))) / cross_product_norm

        # Refracted ray direction
        v_x = normal_vector_coef * ∂₁u_I
        v_y = normal_vector_coef * ∂₂u_I
        v_z = -normal_vector_coef + r

        # Refracted ray starting point: (x_I, y_I, u_I)
        t_screen_int = (z_screen - u_I) / v_z

        if t_screen_int &gt;= 0

            # Screen intersection coordinates
            x_screen = x_I + t_screen_int * v_x
            y_screen = y_I + t_screen_int * v_y

            # Pixel size
            w_screen, h_screen = screen_size
            n_x, n_y = size(render)
            w_pixel = w_screen / n_x
            h_pixel = h_screen / n_y

            # Pixel intersection indices
            n_x, n_y = size(render)

            i = 1 + Int(floor((w_screen / 2 + x_screen) / w_pixel))
            j = 1 + Int(floor((h_screen / 2 + y_screen) / h_pixel))

            # Render contribution from this ray
            i_min = max(i - ray_kernel_size[1] - 1, 1)
            i_max = min(i + ray_kernel_size[1] + 1, n_x)
            j_min = max(j - ray_kernel_size[2] - 1, 1)
            j_max = min(j + ray_kernel_size[2] + 1, n_y)

            w_kernel = (ray_kernel_size[1] + 0.5) * w_pixel
            h_kernel = (ray_kernel_size[2] + 0.5) * h_pixel

            for i_ in i_min:i_max
                contribution_x =
                    F(-0.5w_screen + i_ * w_pixel, x_screen, w_kernel) -
                    F(-0.5w_screen + (i_ - 1) * w_pixel, x_screen, w_kernel)

                for j_ in j_min:j_max
                    contribution_y =
                        F(-0.5h_screen + j_ * h_pixel, y_screen, h_kernel) -
                        F(-0.5h_screen + (j_ - 1) * h_pixel, y_screen, h_kernel)

                    Atomix.@atomic render[i_, j_] += contribution_x * contribution_y
                end
            end
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ray_tracing_kernel (generic function with 4 methods)</code></pre><h2 id="Calling-the-ray-tracing-kernel"><a class="docs-heading-anchor" href="#Calling-the-ray-tracing-kernel">Calling the ray tracing kernel</a><a id="Calling-the-ray-tracing-kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-the-ray-tracing-kernel" title="Permalink"></a></h2><p>Here we define a function which computes the input for the ray tracing kernel from a spline grid and then calls the kernel.</p><pre><code class="language-julia hljs">function trace_rays!(render, control_points_flat, p)::Nothing
    (; spline_grid, u, ∂₁u, ∂₂u) = p

    control_points = reshape(control_points_flat, size(spline_grid.control_points))

    evaluate!(spline_grid; control_points, eval=u)
    evaluate!(spline_grid; control_points, eval=∂₁u, derivative_order=(1, 0))
    evaluate!(spline_grid; control_points, eval=∂₂u, derivative_order=(0, 1))

    render .= 0.0
    ray_tracing_kernel(get_backend(u))(
        render,
        u,
        ∂₁u,
        ∂₂u,
        spline_grid.spline_dimensions[1].sample_points,
        spline_grid.spline_dimensions[2].sample_points,
        p.r,
        p.z_screen,
        p.screen_size,
        p.ray_kernel_size,
        ndrange=size(u)
    )
    return nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">trace_rays! (generic function with 1 method)</code></pre><h2 id="Tracing-the-first-rays"><a class="docs-heading-anchor" href="#Tracing-the-first-rays">Tracing the first rays</a><a id="Tracing-the-first-rays-1"></a><a class="docs-heading-anchor-permalink" href="#Tracing-the-first-rays" title="Permalink"></a></h2><p>Let&#39;s define a flat spline surface and trace some rays. We expect to see a projection of the square lens onto the screen, as all rays travel parallel to the z-axis.</p><pre><code class="language-julia hljs">using SplineGrids
using Plots

n_control_points = (50, 50)
degree = (2, 2)
n_sample_points = (300, 300) # Determines grid of sampled rays
dim_out = 1
extent = (-1.0, 1.0) # Lens extent in both x and y direction

spline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points; max_derivative_order=1, extent)
spline_grid = SplineGrid(spline_dimensions, dim_out)
spline_grid.control_points .= 0

p_render = (;
    spline_grid,
    u=similar(spline_grid.eval),
    ∂₁u=similar(spline_grid.eval),
    ∂₂u=similar(spline_grid.eval),
    r=1.4,
    z_screen=5.0,
    screen_size=(4.0, 4.0),
    ray_kernel_size=(3, 3),
    screen_res=(250, 250)
)

render = zeros(p_render.screen_res)

trace_rays!(render, vec(spline_grid.control_points), p_render)

heatmap(render, aspect_ratio=:equal)</code></pre><img src="c463346a.svg" alt="Example block output"/><h2 id="Defining-the-target-distribution"><a class="docs-heading-anchor" href="#Defining-the-target-distribution">Defining the target distribution</a><a id="Defining-the-target-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-target-distribution" title="Permalink"></a></h2><p>We define a normalized target distribution, which we will compare to normalized renders.</p><pre><code class="language-julia hljs">using LinearAlgebra

target = [
    exp(-(x.^2 + y.^2)^2) for
    x = range(-p_render.screen_size[1] / 2, p_render.screen_size[1] / 2, length=p_render.screen_res[1]),
    y = range(-p_render.screen_size[2] / 2, p_render.screen_size[2] / 2, length=p_render.screen_res[2])
]

normalize!(target)

heatmap(target, aspect_ratio=:equal)</code></pre><img src="00a0255b.svg" alt="Example block output"/><h2 id="The-loss-function"><a class="docs-heading-anchor" href="#The-loss-function">The loss function</a><a id="The-loss-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-loss-function" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Distances

function image_loss(control_points_flat, target, render, p_render)

    trace_rays!(render, control_points_flat, p_render)
    normalize!(render)
    Euclidean()(render, target)
end

render = zeros(p_render.screen_res...)

image_loss(
    vec(spline_grid.control_points),
    target,
    render,
    p_render,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.42417153182181083</code></pre><h2 id="Gradients-w.r.t.-control-points"><a class="docs-heading-anchor" href="#Gradients-w.r.t.-control-points">Gradients w.r.t. control points</a><a id="Gradients-w.r.t.-control-points-1"></a><a class="docs-heading-anchor-permalink" href="#Gradients-w.r.t.-control-points" title="Permalink"></a></h2><p>We can now compute the gradient of the loss function with respect to the control points. Let&#39;s have a look at it.</p><pre><code class="language-julia hljs">using Enzyme

G = make_zero(vec(spline_grid.control_points))
drender = make_zero(render)
dp_render = make_zero(p_render)

autodiff(
    Reverse,
    image_loss,
    Active,
    Duplicated(vec(spline_grid.control_points), G),
    Const(target),
    DuplicatedNoNeed(render, drender),
    DuplicatedNoNeed(p_render, dp_render),
)

heatmap(reshape(G, n_control_points), aspect_ratio=:equal)</code></pre><img src="a4781dcd.svg" alt="Example block output"/><h2 id="Optimizing-the-surface"><a class="docs-heading-anchor" href="#Optimizing-the-surface">Optimizing the surface</a><a id="Optimizing-the-surface-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-the-surface" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Optimization
using OptimizationOptimJL: BFGS

function image_loss_grad!(G, control_points_flat, meta_p)::Nothing
    make_zero!(G)
    make_zero!(meta_p.render_duplicated.dval)
    for val in values(meta_p.p_render_duplicated.dval)
        val isa Union{Array, SplineGrid} &amp;&amp; make_zero!(val)
    end
    autodiff(
        Reverse,
        image_loss,
        Active,
        Duplicated(control_points_flat, G),
        Const(meta_p.target),
        meta_p.render_duplicated,
        meta_p.p_render_duplicated,
    )
    return nothing
end

meta_p = (;
    target,
    render_duplicated = DuplicatedNoNeed(render, drender),
    p_render_duplicated = DuplicatedNoNeed(p_render, dp_render)
)

optimization_function = OptimizationFunction(
    (control_points_flat, p) -&gt; image_loss(
        control_points_flat,
        target,
        render,
        p_render
    ),
    grad = image_loss_grad!
)

prob = OptimizationProblem(
    optimization_function,
    vec(spline_grid.control_points),
    meta_p,
)

sol = solve(prob, BFGS(); maxiters = 50)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Failure
u: 2500-element Vector{Float64}:
 0.025411832126451584
 0.020912715664454552
 0.024981354641295604
 0.026270270561444917
 0.03759047549460235
 0.03340072040976191
 0.03407931644829938
 0.03225715086781632
 0.03290651700284977
 0.03371618714401006
 ⋮
 0.03290651700284928
 0.03225715086781523
 0.03407931644830024
 0.03340072040976014
 0.03759047549460255
 0.026270270561444535
 0.024981354641294924
 0.020912715664454653
 0.02541183212645147</code></pre><h2 id="Viewing-the-optimization-result"><a class="docs-heading-anchor" href="#Viewing-the-optimization-result">Viewing the optimization result</a><a id="Viewing-the-optimization-result-1"></a><a class="docs-heading-anchor-permalink" href="#Viewing-the-optimization-result" title="Permalink"></a></h2><p>The final render looks like this:</p><pre><code class="language-julia hljs">trace_rays!(render, sol.u, p_render)
heatmap(render, aspect_ratio=:equal)</code></pre><img src="b7031d8a.svg" alt="Example block output"/><p>And the lens surface looks like this:</p><pre><code class="language-julia hljs">spline_grid.control_points .= reshape(sol.u, size(spline_grid.control_points))
evaluate!(spline_grid)
plot(spline_grid; plot_knots = false, aspect_ratio=:equal)</code></pre><img src="0f5d91fe.svg" alt="Example block output"/><h2 id="A-peek-into-upcoming-features"><a class="docs-heading-anchor" href="#A-peek-into-upcoming-features">A peek into upcoming features</a><a id="A-peek-into-upcoming-features-1"></a><a class="docs-heading-anchor-permalink" href="#A-peek-into-upcoming-features" title="Permalink"></a></h2><p>One of the neat things we can do with this setup is look at all sorts of gradients. We are most interested in the gradient of the loss with respect to the partial derivatives of the surface, since those are the most important for the rendering result. In particular, we look at the sum of the absolute values of these gradients. This shows which regions of the lens surface the loss is most sensitive to, and thus where the surface might need more degrees of freedom.</p><pre><code class="language-julia hljs">function loss_from_grid(render, u, ∂₁u, ∂₂u, spline_grid, target, p_render)
    ray_tracing_kernel(get_backend(u))(
        render,
        u,
        ∂₁u,
        ∂₂u,
        spline_grid.spline_dimensions[1].sample_points,
        spline_grid.spline_dimensions[2].sample_points,
        p_render.r,
        p_render.z_screen,
        p_render.screen_size,
        p_render.ray_kernel_size,
        ndrange=size(u)
    )
    Euclidean()(render, target)
end

for val in values(meta_p.p_render_duplicated.dval)
    val isa Union{Array, SplineGrid} &amp;&amp; make_zero!(val)
end
autodiff(
    Reverse,
    loss_from_grid,
    Active,
    meta_p.render_duplicated,
    Duplicated(p_render.u, meta_p.p_render_duplicated.dval.u),
    Duplicated(p_render.∂₁u, meta_p.p_render_duplicated.dval.∂₁u),
    Duplicated(p_render.∂₂u, meta_p.p_render_duplicated.dval.∂₂u),
    Duplicated(spline_grid, meta_p.p_render_duplicated.dval.spline_grid),
    Const(target),
    Const(p_render)
)

heatmap(
    abs.(meta_p.p_render_duplicated.dval.∂₁u[:,:,1]) +
    abs.(meta_p.p_render_duplicated.dval.∂₂u[:,:,1]),
    aspect_ratio=:equal)</code></pre><img src="07f91bb3.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples_pde/">« Solving a PDE</a><a class="docs-footer-nextpage" href="../manual/">Manual »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 21 December 2024 10:26">Saturday 21 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

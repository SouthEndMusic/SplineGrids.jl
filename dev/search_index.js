var documenterSearchIndex = {"docs":
[{"location":"examples_pde/#PDE-solving-example","page":"Solving a PDE","title":"PDE solving example","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"In this section we solve the following PDE problem with a spline grid:","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"beginalign*\nbegincases\n    u  Omega rightarrow mathbbR \n    Delta u = u^3 text for  mathbfx in Omega \n    u = g(mathbfx)  text for  mathbfx in partialOmega\nendcases\nendalign*","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"where the domain is given by the open unit cube: Omega = (01)^3. We assume that g(xyz) = 0 for z in (01) and g(xyz) = f(xy) for z = 0 1.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We solve this problem by sampling the domain and enforcing the PDE on the interior points and the boundary condition on the boundary points. ","category":"page"},{"location":"examples_pde/#The-residual-kernel","page":"Solving a PDE","title":"The residual kernel","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We first define the kernel which calculates the residual of a given approximation to the solution of the problem above. Note that this kernel is agnostic of the fact that the solution will come from a spline grid.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"using KernelAbstractions\n\n@kernel function pde_residual_kernel(\n    residual,\n    @Const(f),\n    @Const(u),\n    @Const(∂₁²u),\n    @Const(∂₂²u),\n    @Const(∂₃²u),\n)\n    I = @index(Global, Cartesian)\n\n    is_boundary = false\n    for (i, i_max) in zip(Tuple(I)[1:end-1], size(residual)[1:end-1])\n        if (i == 1) || (i == i_max)\n            is_boundary = true\n            break\n        end\n    end\n\n    residual[I] = if is_boundary\n        if I[3] == 1 || I[3] == size(residual)[3]\n            u[I] - f[I[1], I[2]]\n        else\n            u[I]\n        end\n    else\n        ∂₁²u[I] + ∂₂²u[I] + ∂₃²u[I] - u[I]^3\n    end\nend","category":"page"},{"location":"examples_pde/#The-residual-as-a-function-of-the-spline-grid-control-points","page":"Solving a PDE","title":"The residual as a function of the spline grid control points","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"Whe now define a function which generates the input of the above residual kernel from a spline grid and computes the residual in place. It assumes a parameter object with the spline grid, f (an array that specifies the boundary condition for the bottom and top of the domain, the boundary condition is 0 elsewhere) and caches for the spline grid evaluation.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"function pde_residual!(residual, control_points_flat, p)::Nothing\n    (; spline_grid, f, u, ∂₁²u, ∂₂²u, ∂₃²u) = p\n\n    control_points = reshape(\n        control_points_flat,\n        size(spline_grid.control_points)\n    )\n\n    evaluate!(spline_grid; control_points, eval=u)\n    evaluate!(spline_grid; control_points, eval=∂₁²u, derivative_order=(2, 0, 0))\n    evaluate!(spline_grid; control_points, eval=∂₂²u, derivative_order=(0, 2, 0))\n    evaluate!(spline_grid; control_points, eval=∂₃²u, derivative_order=(0, 0, 2))\n\n    pde_residual_kernel(get_backend(u))(\n        reshape(residual, size(u)),\n        f,\n        u,\n        ∂₁²u,\n        ∂₂²u,\n        ∂₃²u,\n        ndrange=size(u)\n    )\n\n    return nothing\nend","category":"page"},{"location":"examples_pde/#Defining-the-spline-grid","page":"Solving a PDE","title":"Defining the spline grid","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We would like to define a residual function mathbbR^N rightarrow mathbbR^N, i.e. the number of sample points must equal the number of control points. For each dimension the maximum derivative order is 2, to evaluate the result of the Laplacian operator on the spline.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"using SplineGrids\n\nn_control_points = (25, 25, 25)\ndegree = (2, 2, 2)\nn_sample_points = n_control_points\ndim_out = 1\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points; max_derivative_order = 2)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid","category":"page"},{"location":"examples_pde/#Defining-the-boundary-condition","page":"Solving a PDE","title":"Defining the boundary condition","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We define a boundary condition inspired by the Julia logo.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"using GLMakie\n\nfunction hill(x, y, x0, y0, β)\n    r = sqrt((x - x0)^2 + (y - y0)^2)\n    return exp(-(r / β)^2)\nend\n\nfunction hills(x, y)\n    R = 0.25\n    out = 0.0\n    for θ in range(0, 2π, length=4)[1:end-1]\n        x0 = 0.5 + R * cos(θ)\n        y0 = 0.5 + R * sin(θ)\n        out += hill(x, y, x0, y0, R / 2)\n    end\n    return 100 * out\nend\n\n\nf = [\n    hills.(x, y) for\n    x = spline_dimensions[1].sample_points,\n    y = spline_dimensions[2].sample_points\n]\n\nheatmap(f)","category":"page"},{"location":"examples_pde/#Defining-the-problem","page":"Solving a PDE","title":"Defining the problem","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We will solve the problem with a Jacobian free Newton-Krylov method. To do this, we need to provide a Jacobian-vector product (JVP) function.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"using NonlinearSolve\nusing Enzyme\n\np = (;\n    spline_grid,\n    f,\n    u = similar(spline_grid.eval),\n    ∂₁²u = similar(spline_grid.eval),\n    ∂₂²u = similar(spline_grid.eval),\n    ∂₃²u = similar(spline_grid.eval)\n)\n\nmeta_p = (; \n    residual = similar(spline_grid.eval),\n    p_duplicated = DuplicatedNoNeed(p, make_zero(p))\n)\n\nfunction pde_residual_jvp!(Jv, v, control_points_flat, meta_p)::Nothing\n    for val in values(meta_p.p_duplicated.dval)\n        make_zero!(val)\n    end\n    autodiff(\n        Forward,\n        pde_residual!,\n        DuplicatedNoNeed(vec(meta_p.residual), Jv),\n        Duplicated(control_points_flat, v),\n        meta_p.p_duplicated\n    )\n    return nothing\nend\n\nnonlinear_function = NonlinearFunction(\n    (residual, control_points_flat, p_) -> pde_residual!(residual, control_points_flat, p);\n    jvp = pde_residual_jvp!\n)\n\n# Initial guess\nx0 = zeros(length(spline_grid.control_points))\n\nproblem = NonlinearProblem(\n    nonlinear_function,\n    x0,\n    meta_p\n)","category":"page"},{"location":"examples_pde/#Solving-the-problem","page":"Solving a PDE","title":"Solving the problem","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"sol = solve(problem, NewtonRaphson(linsolve = KrylovJL_GMRES()))","category":"page"},{"location":"examples_pde/#Viewing-the-solution","page":"Solving a PDE","title":"Viewing the solution","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"spline_grid.control_points .= reshape(sol.u, size(spline_grid.control_points))\nevaluate!(spline_grid)\nfig = Figure()\nax, plt = volume(fig[1,1], log.(spline_grid.eval[:, :, :, 1] .+ 1))\nColorbar(fig[1,2], plt; label = L\"\\log(u + 1)\")\nfig","category":"page"},{"location":"examples_dimensions/#Dimensionality-examples","page":"Dimensionality","title":"Dimensionality examples","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"This page shows examples of spline grids of various dimensionalities via their plotting recipes.","category":"page"},{"location":"examples_dimensions/#1-input,-1-output","page":"Dimensionality","title":"1 input, 1 output","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"using SplineGrids\nusing Plots\n\n# Spline grid parameters\nn_control_points = 10\ndegree = 3\nn_sample_points = 250\ndim_out = 1\n\n# Define spline grid\nspline_dimension = SplineDimension(n_control_points, degree, n_sample_points, extent=(3.0, 5.0))\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nspline_grid.control_points .= [0.342, 0.633, 0.446, 0.716, 0.843, 0.171, 0.061, 0.973, 0.057, 0.671]\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#1-input,-2-outputs","page":"Dimensionality","title":"1 input, 2 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = 10\ndegree = 2\nn_sample_points = 250\ndim_out = 2\n\n# Define spline grid\nspline_dimension = SplineDimension(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nr = 1:n_control_points\nθ = 1:n_control_points\nspline_grid.control_points[:, 1] .= @. r * cos(θ)\nspline_grid.control_points[:, 2] .= @. r * sin(θ)\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#1-input,-3-outputs","page":"Dimensionality","title":"1 input, 3 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = 10\ndegree = 2\nn_sample_points = 250\ndim_out = 3\n\n# Define spline grid\nspline_dimension = SplineDimension(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nr = 1:n_control_points\nθ = 1:n_control_points\nz = 1:n_control_points\nspline_grid.control_points[:, 1] .= @. r * cos(θ)\nspline_grid.control_points[:, 2] .= @. r * sin(θ)\nspline_grid.control_points[:, 3] .= z\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#1-input,-4-outputs","page":"Dimensionality","title":"1 input, 4 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = 10\ndegree = 2\nn_sample_points = 250\ndim_out = 4\n\n# Define spline grid\nspline_dimension = SplineDimension(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nr = 1:n_control_points\nθ = 1:n_control_points\nz = 1:n_control_points\nc = sin.(z)\nspline_grid.control_points[:, 1] .= @. r * cos(θ)\nspline_grid.control_points[:, 2] .= @. r * sin(θ)\nspline_grid.control_points[:, 3] .= z\nspline_grid.control_points[:, 4] .= c\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#2-inputs,-1-output","page":"Dimensionality","title":"2 inputs, 1 output","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = (5, 6)\ndegree = (2, 2)\nn_sample_points = (60, 50)\ndim_out = 1\n\n# Define spline grid\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\n\n# Set control points\nspline_grid.control_points .= 0\nspline_grid.control_points[1:2:end] .= 1:prod(n_control_points)/2\n\n# Evaluate spline grid \nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#2-inputs,-2-outputs","page":"Dimensionality","title":"2 inputs, 2 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = (4, 4)\ndegree = (2, 3)\nn_sample_points = (15, 20)\ndim_out = 2\n\n# Define spline grid\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\n\n# Set control points\nspline_grid.control_points .= [-0.358 0.795 -0.016 -0.295; 0.923 -0.182 -0.644 0.612; -0.91 0.708 -0.426 0.412; 0.56 -0.78 0.515 0.676;;; 0.938 0.393 -0.702 -0.99; -0.578 0.305 -0.842 -0.57; 0.034 -0.813 -0.514 0.162; -0.016 -0.822 -0.261 -0.148]\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#2-inputs,-3-outputs","page":"Dimensionality","title":"2 inputs, 3 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = (25, 2)\ndegree = (3, 1)\nn_sample_points = (100, 100)\ndim_out = 3\n\n# Define spline grid\nspline_dimension = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nR = 3\nr = 1\nρ = range(-r, r, length=n_control_points[2])\nfor (i, θ) in enumerate(range(0, 2π, length=n_control_points[1]))\n    ϕ = 2θ\n    spline_grid.control_points[i, :, 1] .= @. (R + ρ * cos(ϕ)) * cos(θ)\n    spline_grid.control_points[i, :, 2] .= @. (R + ρ * cos(ϕ)) * sin(θ)\n    spline_grid.control_points[i, :, 3] .= ρ * sin(ϕ)\nend\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_linear_fitting/#Linear-fitting-example","page":"Linear fitting","title":"Linear fitting example","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"In this section we demonstrate how a spline grid can be fitted. We will fit a spline surface to the following image.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using Images\nimage = load(normpath(@__DIR__, \"julia_logo.png\"))","category":"page"},{"location":"examples_linear_fitting/#Defining-the-spline-grid","page":"Linear fitting","title":"Defining the spline grid","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"We define a spline grid with 2 input dimensions, 1 output dimension and a sample grid which matches the image resolution.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using SplineGrids\n\nn_control_points = (40, 40)\ndegree = (2, 2)\nimage_array = Float64.(Gray.(image[end:-1:1, :]))'\nn_sample_points = size(image_array)\ndim_out = 1\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid","category":"page"},{"location":"examples_linear_fitting/#Fitting","page":"Linear fitting","title":"Fitting","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"We fit the spline surface to the image in a least squares sense, by interpreting the spline grid evaluation as a linear mapping.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using LinearMaps\nusing IterativeSolvers\nusing Plots\n\nspline_grid_map = LinearMap(spline_grid)\nsol = lsqr(spline_grid_map, vec(image_array))\nspline_grid.control_points .= reshape(sol, size(spline_grid.control_points))\nevaluate!(spline_grid)\nplot(spline_grid)","category":"page"},{"location":"examples_linear_fitting/#Matrix","page":"Linear fitting","title":"Matrix","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"The least-squares fitting procedure above is matrix free, but the linear mapping can be converted into a (sparse) matrix for inspection.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using SparseArrays\n\nn_control_points = (5, 5)\ndegree = (2, 2)\nn_sample_points = (15, 15)\ndim_out = 1\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid_map = LinearMap(spline_grid)\nM = sparse(spline_grid_map)\nheatmap(M[end:-1:1,:])","category":"page"},{"location":"manual/#Constructors","page":"Manual","title":"Constructors","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"KnotVector(::Integer, ::Integer)\nSplineDimension(::Integer, ::Integer, ::Integer)\nSplineGrid(::NTuple{N_in, <:SplineDimension}, ::Integer) where N_in","category":"page"},{"location":"manual/#SplineGrids.KnotVector-Tuple{Integer, Integer}","page":"Manual","title":"SplineGrids.KnotVector","text":"KnotVector(n_basis_functions::Integer, degree::Integer; extent::Tuple{Number, Number} = (0,1), distribution::Symbol = :equispaced)\n\nConstruct a clamped knot vector, i.e. the multiplicity of the first and last knot is degree + 1 and the other multiplicities are 1.\n\nArguments\n\nn_basis_functions: The number of basis functions that will be defined on this knot vector\ndegree: The degree of the basis functions that will be defined on this knot vector\n\nKeyword Arguments\n\nextent: A tuple (tmin, tmax) defining the extend of the knot vector\ndistribution: The distribution of the internal knots. The options are :equispaced or :random\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.SplineDimension-Tuple{Integer, Integer, Integer}","page":"Manual","title":"SplineGrids.SplineDimension","text":"SplineDimension(n_basis_functions::Integer, degree::Integer, n_sample_points::Integer; kwargs...)::SplineDimension\n\nConstructor for a SplineDimension. For now the sample points are evenly spaced on the extent of the knot vector. Key word arguments are passed to the KnotVector constructor.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.SplineGrid-Union{Tuple{N_in}, Tuple{NTuple{N_in, var\"#s73\"} where var\"#s73\"<:SplineDimension, Integer}} where N_in","page":"Manual","title":"SplineGrids.SplineGrid","text":"SplineGrid(spline_dimensions::NTuple{N_in, <:SplineDimension}, dim_out::Integer)\n\nDefine a SplineGrid from an NTuple of spline dimensions and the number of output dimensions.\n\nInputs\n\nspline_dimensions: an NTuple of spline dimensions\nNout: The number of output dimensions. I.e. the control points and thus the spline live in ℝ^Nout.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Evaluation","page":"Manual","title":"Evaluation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"evaluate!(::SplineDimension)\nevaluate!(::SplineGrids.AbstractSplineGrid{Nin, Nout}) where {Nin, Nout}\nevaluate_adjoint!(::SplineGrids.AbstractSplineGrid{Nin, Nout}) where{Nin, Nout}","category":"page"},{"location":"manual/#SplineGrids.evaluate!-Tuple{SplineDimension}","page":"Manual","title":"SplineGrids.evaluate!","text":"evaluate!(spline_dimension)\n\nPer sample point, get the value of the spline_dimension.degree + 1 basis functions that have a non-zero value for that sample point. This is based on the Cox-de Boor recursion formula.\n\nThe l-th sample point t has sample index i, meaning that t ∈ [tᵢ, tᵢ₊₁). Therefore Bᵢ₀(t) = 1, Bⱼ₀(t) = 0 for j ≠ i. For degree k, t is in the domain of Bⱼₖ which is [tⱼ, tⱼ₊ₖ₊₁), for j = i - k, ..., i.\n\nArguments\n\nspline_dimension\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout}}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout}","page":"Manual","title":"SplineGrids.evaluate!","text":"evaluate!spline_grid::AbstractSplineGrid{Nin};\n    derivative_order::NTuple{Nin, <:Integer} = ntuple(_ -> 0, Nin),\n    control_points::AbstractArray = spline_grid.control_points,\n    eval::AbstractArray = spline_grid.eval)\n\nEvaluate the spline grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a linear combination of control with basis function products as coefficients.\n\nUses the control_points and eval arrays from the spline_grid by default, but different arrays can be specified as a convencience for optimization algorithms.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.evaluate_adjoint!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout}}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout}","page":"Manual","title":"SplineGrids.evaluate_adjoint!","text":"evaluate_adjoint!(spline_grid::AbstractSplineGrid{Nin};\n    derivative_order::NTuple{Nin, <:Integer} = ntuple(_ -> 0, Nin),\n    control_points::AbstractArray = spline_grid.control_points,\n    eval::AbstractArray = spline_grid.eval)\n\nevaluate the adjoint of the linear mapping control_points -> eval. This is a computation of the form eval -> control_points. If we write evaluate!(spline_grid) as a matrix vector multiplication eval = M * control_points, Then the adjoint is given by v -> M' * v. This mapping is used in fitting algorithms.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Structs","page":"Manual","title":"Structs","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"KnotVector\nSplineDimension\nSplineGrid","category":"page"},{"location":"manual/#SplineGrids.KnotVector","page":"Manual","title":"SplineGrids.KnotVector","text":"KnotVector(knots, multiplicities)\n\nDefines a knot vector.\n\nArguments\n\nknot_values: The values in the knot vector. Must be strictly increasing.\nmultiplicities: The multiplicity of each knot in knots.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SplineGrids.SplineDimension","page":"Manual","title":"SplineGrids.SplineDimension","text":"SplineDimension(degree, knot_vector, sample_points, sample_indices)\n\nDefines the set of basis functions for a single dimension, and how it is sampled.\n\nArguments\n\ndegree: The degree of the piecewise polynomial basis functions.\nmax_derivative_order: The maximum derivative order of the basis functions that will be computed.\nknot_vector: The knot vector on which the basis functions are defined.\nsample_points: The points in the domain of the basis functions where they are sampled. Must\nlie within the boundaries of the knot vector.\nsample_indices: The indices i of the sample points t in the knot vector such that knot_vector.knots[i] ≤ t < knot_vector.knots[i + 1]`\neval: An array of shape (length(sample_points), degree + 1, max_derivative + 1), with per sample point the values of those basis functions\neval_prev: Helper array for intermediate results in the basis function computations whose support the sample point is in, and the derivatives if requested.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SplineGrids.SplineGrid","page":"Manual","title":"SplineGrids.SplineGrid","text":"The SplineGrid is the central object of the SplineGrids.jl package, containing all information to evaluate the defined spline on the defined grid.\n\nFields\n\nspline_dimensions: A SplineDimension per dimension of the spline, containing data to evaluate basis functions.\nsample_indices: For each global sample point, the linear index in the control_points array before it is offset for a particular index in the control point kernel and output dimension.\ncontrol points: The points that define the shape of the spline, and in how many dimensions it is embedded.\nweights: For now unsupported, will eventually be used to define NURBS.\neval: The array where the evaluated spline grid is stored.\nbasis_function_products: An array of intermediate results for evaluating the spline grids, containing products of basis functions from the various spline dimensions.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Utility-functions","page":"Manual","title":"Utility functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"decompress","category":"page"},{"location":"manual/#SplineGrids.decompress","page":"Manual","title":"SplineGrids.decompress","text":"Transform spline_dimension.eval into a matrix of shape (n_sample_points, n_points - degree - 1) which explicitly gives the value for each basis function at each sample point.\n\n\n\n\n\n","category":"function"},{"location":"examples_derivatives/#Derivatives-example","page":"Derivatives","title":"Derivatives example","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"The code below shows an example of how derivatives can be used to compute the normal vectors of a surface.","category":"page"},{"location":"examples_derivatives/#Defining-the-surface","page":"Derivatives","title":"Defining the surface","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using SplineGrids\n\n# Spline Grid Parameters\nn_control_points = (5, 5)\ndegree = (2, 2)\nn_sample_points = (100, 100)\nNout = 3\nmax_derivative_order = 1\n\n# Define the spline grid\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points; max_derivative_order)\nspline_grid = SplineGrid(spline_dimensions, Nout)\nfor i in 1:n_control_points[1]\n    for j in 1:n_control_points[2]\n        spline_grid.control_points[i, j, 3] = exp(-((i - 3)^2 + (j - 3)^2))\n    end\nend","category":"page"},{"location":"examples_derivatives/#Inspecting-the-basis-functions","page":"Derivatives","title":"Inspecting the basis functions","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"Let's look at the basis functions for the first dimension:","category":"page"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using Plots\n\nplot(spline_dimensions[1])","category":"page"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"and the derivatives of these basis functions:","category":"page"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using Plots\n\nplot(spline_dimensions[1]; derivative_order = 1)","category":"page"},{"location":"examples_derivatives/#Evaluating-the-surface","page":"Derivatives","title":"Evaluating the surface","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"The data is copied because spline_grid.eval will be overwritten below when computing the partial derivatives.","category":"page"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"evaluate!(spline_grid)\nspline_grid_data = copy(spline_grid.eval)\nnothing","category":"page"},{"location":"examples_derivatives/#Computing-the-partial-derivatives","page":"Derivatives","title":"Computing the partial derivatives","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"# Derivatives of the surface with respect to the first dimension parameter\nevaluate!(spline_grid; derivative_order=(1, 0))\n∂₁spline_grid_data = copy(spline_grid.eval)\n\n# Derivatives of the surface with respect to the second dimension parameter\nevaluate!(spline_grid; derivative_order=(0, 1))\n∂₂spline_grid_data = spline_grid.eval\nnothing","category":"page"},{"location":"examples_derivatives/#Computing-the-normal-vectors","page":"Derivatives","title":"Computing the normal vectors","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using LinearAlgebra\n\nnormal_vectors = similar(spline_grid_data)\nfor i in 1:n_sample_points[1]\n    for j in 1:n_sample_points[2]\n        normal_vectors[i, j, :] .= cross(\n            view(∂₁spline_grid_data, i, j, :),\n            view(∂₂spline_grid_data, i, j, :)\n        )\n        normal_vectors[i, j, :] ./= 10 * norm(view(normal_vectors, i, j, :))\n    end\nend","category":"page"},{"location":"examples_derivatives/#Plotting","page":"Derivatives","title":"Plotting","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using CairoMakie\n\n# Plotting the surface\nf = Figure()\nax = Axis3(f[1, 1])\nCairoMakie.surface!(ax, eachslice(spline_grid_data, dims=3)...)\n\n# Plotting a subset of the normal vectors\nspline_grid_data_reshaped = reshape(spline_grid_data, (prod(n_sample_points), 3))\nnormal_vectors_reshaped = reshape(normal_vectors, (prod(n_sample_points), 3))\n\nCairoMakie.quiver!(\n    ax,\n    eachslice(view(spline_grid_data_reshaped, 1:192:prod(n_sample_points), :), dims=2)...,\n    eachslice(view(normal_vectors_reshaped, 1:192:prod(n_sample_points), :), dims=2)...,\n    arrowsize=0.03,\n)\n\nCairoMakie.xlims!(0, 1)\nCairoMakie.ylims!(0, 1)\n\nf","category":"page"},{"location":"examples_enzyme/#Enzyme-example","page":"Control point derivatives with Enzyme","title":"Enzyme example","text":"","category":"section"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"To demonstrate how Enzyme can be used to incorporate a spline grid into an optimization pipeline, we show what the derivative of a spline grid with respect to one control point looks like.","category":"page"},{"location":"examples_enzyme/#Defining-the-spline-grid","page":"Control point derivatives with Enzyme","title":"Defining the spline grid","text":"","category":"section"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"We define a spline grid with 2 input dimensions and 1 output dimension.","category":"page"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"using SplineGrids\n\nn_control_points = (10, 10)\ndegree = (2, 2)\nn_sample_points = (100, 100)\ndim_out = 1\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid.control_points .= 0\nspline_grid","category":"page"},{"location":"examples_enzyme/#Gradient-demonstration","page":"Control point derivatives with Enzyme","title":"Gradient demonstration","text":"","category":"section"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"Here we show what the gradient of the output surface with respect to one control point looks like. ","category":"page"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"using Enzyme\nusing Plots\n\ndspline_grid = deepcopy(spline_grid)\ndspline_grid.control_points[5, 5] = 1\n\nout = autodiff(Forward, Duplicated(spline_grid, dspline_grid)) do spline_grid\n    evaluate!(spline_grid)\n    spline_grid.eval\nend\n\nheatmap(out[1][:, :, 1])","category":"page"},{"location":"examples_optics/#Lens-geometry-optimization-example","page":"Optimizing a lens surface","title":"Lens geometry optimization example","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"In this section we optimize the surface of a lens to yield a target irradiance distribution on a screen. This process is called caustic design. Below a schematic of the simulated setup is shown.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using CairoMakie # hide\nusing Makie.GeometryBasics # hide\n\nfig = Figure() # hide\nax = Axis(fig[1,1]; xlabel = \"z axis\") # hide\n\n# Incoming beam # hide\nn_rays = 10 # hide\narrows!(ax, # hide\n    fill(-2.0, n_rays), # hide\n    range(-1,1, length = n_rays), # hide\n    ones(n_rays),  # hide\n    zeros(n_rays), # hide\n    label = \"Incoming parallel beam\" # hide\n) # hide\n\n# Lens first surface # hide\nn_points = 100  # hide\ny_lens = range(-1,1, length = n_points) # hide\nx_lens_1 = fill(-0.5, n_points) # hide\nlines!(ax, # hide\n    x_lens_1,  # hide\n    y_lens, # hide\n    label = \"Fixed lens surface\" # hide\n) # hide\n\n# Lens second surface # hide\nx_lens_2 = sin.(10y_lens)/25  # hide\nlines!(ax, # hide\n    x_lens_2, # hide\n    y_lens, # hide\n    label = \"Lens surface to optimize\", # hide\n) # hide\n\n# Lens fill # hide\npoly!( # hide\n    ax, # hide\n    [ # hide\n        Point2f.(x_lens_1, y_lens)..., # hide\n        Point2f.(x_lens_2[end:-1:1], y_lens[end:-1:1])... # hide\n    ], # hide\n    color = (:blue, 0.2), # hide\n) # hide\n\n# Detector screen # hide\nlines!( # hide\n    ax, # hide\n    [2.0, 2.0], # hide\n    [-3.0, 3.0], # hide\n    label = \"Detector screen\" # hide\n) # hide\n\naxislegend(ax, position = :lt) # hide\nhidexdecorations!(ax, label = false) # hide\nhideydecorations!(ax) # hide\n\nfig # hide","category":"page"},{"location":"examples_optics/#Differentiable-ray-tracing-kernel","page":"Optimizing a lens surface","title":"Differentiable ray tracing kernel","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"Here we define a kernel which computes for each sample point on the surface:","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"at which direction a ray leaves that point by Snell's law;\nwhere that ray intersects the detector screen;\nWhat the contributions of that ray to the pixel values are.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"The contribution of the ray is smeared out over multiple pixels in a smooth way to make the rendering differentiable.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using KernelAbstractions\nusing Atomix\n\n# Kernel function for computing the contribution of a ray intersection to the\n# pixels close to the intersection.\nfunction F(x, x0, w)\n    if x < x0 - w\n        -one(x) / 2\n    elseif x > x0 + w\n        one(x) / 2\n    else\n        x_transformed = (x - x0) / w\n        (sin(π * x_transformed) / π + x_transformed) / 2\n    end\nend\n\n@kernel function ray_tracing_kernel(\n    render,\n    @Const(u),\n    @Const(∂₁u),\n    @Const(∂₂u),\n    @Const(x),\n    @Const(y),\n    r,\n    z_screen,\n    screen_size,\n    ray_kernel_size,\n)\n\n    I = @index(Global, Cartesian)\n\n    u_I = u[I]\n    ∂₁u_I = ∂₁u[I]\n    ∂₂u_I = ∂₂u[I]\n\n    x_I = x[I[1]]\n    y_I = y[I[2]]\n\n    # x direction tangent vector: (1, 0, ∂₁u[I])\n    # y direction tangent vector: (0, 1, ∂₂u[I])\n    # -cross product (surface normal): n = (∂₁u[I], ∂₂u[I], -1) / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)\n    # light vector: ℓ = (0, 0, 1)\n    # Snell's law (vector form):\n    # c = -⟨n, ℓ⟩ = 1 / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)\n    # v = r * (0, 0, 1) + (r * c - √(1 - r^2 * (1 - c^2))) * (∂₁u[I], ∂₂u[I], -1) / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)\n\n    cross_product_norm = √(1 + ∂₁u_I^2 + ∂₂u_I^2)\n    c = 1 / cross_product_norm\n    sqrt_arg = 1 - r^2 * (1 - c^2)\n    if sqrt_arg >= 0\n        normal_vector_coef = (r * c - √(1 - r^2 * (1 - c^2))) / cross_product_norm\n\n        # Refracted ray direction\n        v_x = normal_vector_coef * ∂₁u_I\n        v_y = normal_vector_coef * ∂₂u_I\n        v_z = -normal_vector_coef + r\n\n        # Refracted ray starting point: (x_I, y_I, u_I)\n        t_screen_int = (z_screen - u_I) / v_z\n\n        if t_screen_int >= 0\n\n            # Screen intersection coordinates\n            x_screen = x_I + t_screen_int * v_x\n            y_screen = y_I + t_screen_int * v_y\n\n            # Pixel size\n            w_screen, h_screen = screen_size\n            n_x, n_y = size(render)\n            w_pixel = w_screen / n_x\n            h_pixel = h_screen / n_y\n\n            # Pixel intersection indices\n            n_x, n_y = size(render)\n\n            i = 1 + Int(floor((w_screen / 2 + x_screen) / w_pixel))\n            j = 1 + Int(floor((h_screen / 2 + y_screen) / h_pixel))\n\n            # Render contribution from this ray\n            i_min = max(i - ray_kernel_size[1] - 1, 1)\n            i_max = min(i + ray_kernel_size[1] + 1, n_x)\n            j_min = max(j - ray_kernel_size[2] - 1, 1)\n            j_max = min(j + ray_kernel_size[2] + 1, n_y)\n\n            w_kernel = (ray_kernel_size[1] + 0.5) * w_pixel\n            h_kernel = (ray_kernel_size[2] + 0.5) * h_pixel\n\n            for i_ in i_min:i_max\n                contribution_x =\n                    F(-0.5w_screen + i_ * w_pixel, x_screen, w_kernel) -\n                    F(-0.5w_screen + (i_ - 1) * w_pixel, x_screen, w_kernel)\n\n                for j_ in j_min:j_max\n                    contribution_y =\n                        F(-0.5h_screen + j_ * h_pixel, y_screen, h_kernel) -\n                        F(-0.5h_screen + (j_ - 1) * h_pixel, y_screen, h_kernel)\n\n                    Atomix.@atomic render[i_, j_] += contribution_x * contribution_y\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"examples_optics/#Calling-the-ray-tracing-kernel","page":"Optimizing a lens surface","title":"Calling the ray tracing kernel","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"Here we define a function which computes the input for the ray tracing kernel from a spline grid and then calls the kernel.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"function trace_rays!(render, control_points_flat, p)::Nothing\n    (; spline_grid, u, ∂₁u, ∂₂u) = p\n\n    control_points = reshape(control_points_flat, size(spline_grid.control_points))\n\n    evaluate!(spline_grid; control_points, eval=u)\n    evaluate!(spline_grid; control_points, eval=∂₁u, derivative_order=(1, 0))\n    evaluate!(spline_grid; control_points, eval=∂₂u, derivative_order=(0, 1))\n\n    render .= 0.0\n    ray_tracing_kernel(get_backend(u))(\n        render,\n        u,\n        ∂₁u,\n        ∂₂u,\n        spline_grid.spline_dimensions[1].sample_points,\n        spline_grid.spline_dimensions[2].sample_points,\n        p.r,\n        p.z_screen,\n        p.screen_size,\n        p.ray_kernel_size,\n        ndrange=size(u)\n    )\n    return nothing\nend","category":"page"},{"location":"examples_optics/#Tracing-the-first-rays","page":"Optimizing a lens surface","title":"Tracing the first rays","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"Let's define a flat spline surface and trace some rays. We expect to see a projection of the square lens onto the screen, as all rays travel parallel to the z-axis.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using SplineGrids\nusing Plots\n\nn_control_points = (50, 50)\ndegree = (2, 2)\nn_sample_points = (300, 300) # Determines grid of sampled rays\ndim_out = 1\nextent = (-1.0, 1.0) # Lens extent in both x and y direction\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points; max_derivative_order=1, extent)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid.control_points .= 0\n\np_render = (;\n    spline_grid,\n    u=similar(spline_grid.eval),\n    ∂₁u=similar(spline_grid.eval),\n    ∂₂u=similar(spline_grid.eval),\n    r=1.4,\n    z_screen=5.0,\n    screen_size=(4.0, 4.0),\n    ray_kernel_size=(3, 3),\n    screen_res=(250, 250)\n)\n\nrender = zeros(p_render.screen_res)\n\ntrace_rays!(render, vec(spline_grid.control_points), p_render)\n\nheatmap(render, aspect_ratio=:equal)","category":"page"},{"location":"examples_optics/#Defining-the-target-distribution","page":"Optimizing a lens surface","title":"Defining the target distribution","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"We define a normalized target distribution, which we will compare to normalized renders.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using LinearAlgebra\n\ntarget = [\n    exp(-(x.^2 + y.^2)^2) for\n    x = range(-p_render.screen_size[1] / 2, p_render.screen_size[1] / 2, length=p_render.screen_res[1]),\n    y = range(-p_render.screen_size[2] / 2, p_render.screen_size[2] / 2, length=p_render.screen_res[2])\n]\n\nnormalize!(target)\n\nheatmap(target, aspect_ratio=:equal)","category":"page"},{"location":"examples_optics/#The-loss-function","page":"Optimizing a lens surface","title":"The loss function","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using Distances\n\nfunction image_loss(control_points_flat, target, render, p_render)\n\n    trace_rays!(render, control_points_flat, p_render)\n    normalize!(render)\n    Euclidean()(render, target)\nend\n\nrender = zeros(p_render.screen_res...)\n\nimage_loss(\n    vec(spline_grid.control_points),\n    target,\n    render,\n    p_render,\n)","category":"page"},{"location":"examples_optics/#Gradients-w.r.t.-control-points","page":"Optimizing a lens surface","title":"Gradients w.r.t. control points","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"We can now compute the gradient of the loss function with respect to the control points. Let's have a look at it.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using Enzyme\n\nG = make_zero(vec(spline_grid.control_points))\ndrender = make_zero(render)\ndp_render = make_zero(p_render)\n\nautodiff(\n    Reverse,\n    image_loss,\n    Active,\n    Duplicated(vec(spline_grid.control_points), G),\n    Const(target),\n    DuplicatedNoNeed(render, drender),\n    DuplicatedNoNeed(p_render, dp_render),\n)\n\nheatmap(reshape(G, n_control_points), aspect_ratio=:equal)","category":"page"},{"location":"examples_optics/#Optimizing-the-surface","page":"Optimizing a lens surface","title":"Optimizing the surface","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using Optimization\nusing OptimizationOptimJL: BFGS\n\nfunction image_loss_grad!(G, control_points_flat, meta_p)::Nothing\n    make_zero!(G)\n    make_zero!(meta_p.render_duplicated.dval)\n    for val in values(meta_p.p_render_duplicated.dval)\n        val isa Union{Array, SplineGrid} && make_zero!(val)\n    end\n    autodiff(\n        Reverse,\n        image_loss,\n        Active,\n        Duplicated(control_points_flat, G),\n        Const(meta_p.target),\n        meta_p.render_duplicated,\n        meta_p.p_render_duplicated,\n    )\n    return nothing\nend\n\nmeta_p = (;\n    target,\n    render_duplicated = DuplicatedNoNeed(render, drender),\n    p_render_duplicated = DuplicatedNoNeed(p_render, dp_render)\n)\n\noptimization_function = OptimizationFunction(\n    (control_points_flat, p) -> image_loss(\n        control_points_flat,\n        target,\n        render,\n        p_render\n    ),\n    grad = image_loss_grad!\n)\n\nprob = OptimizationProblem(\n    optimization_function,\n    vec(spline_grid.control_points),\n    meta_p,\n)\n\nsol = solve(prob, BFGS(); maxiters = 50)","category":"page"},{"location":"examples_optics/#Viewing-the-optimization-result","page":"Optimizing a lens surface","title":"Viewing the optimization result","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"The final render looks like this:","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"trace_rays!(render, sol.u, p_render)\nheatmap(render, aspect_ratio=:equal)","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"And the lens surface looks like this:","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"spline_grid.control_points .= reshape(sol.u, size(spline_grid.control_points))\nevaluate!(spline_grid)\nplot(spline_grid; plot_knots = false, aspect_ratio=:equal)","category":"page"},{"location":"examples_optics/#A-peek-into-upcoming-features","page":"Optimizing a lens surface","title":"A peek into upcoming features","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"One of the neat things we can do with this setup is look at all sorts of gradients. We are most interested in the gradient of the loss with respect to the partial derivatives of the surface, since those are the most important for the rendering result. In particular, we look at the sum of the absolute values of these gradients. This shows which regions of the lens surface the loss is most sensitive to, and thus where the surface might need more degrees of freedom.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"function loss_from_grid(render, u, ∂₁u, ∂₂u, spline_grid, target, p_render)\n    ray_tracing_kernel(get_backend(u))(\n        render,\n        u,\n        ∂₁u,\n        ∂₂u,\n        spline_grid.spline_dimensions[1].sample_points,\n        spline_grid.spline_dimensions[2].sample_points,\n        p_render.r,\n        p_render.z_screen,\n        p_render.screen_size,\n        p_render.ray_kernel_size,\n        ndrange=size(u)\n    )\n    Euclidean()(render, target)\nend\n\nfor val in values(meta_p.p_render_duplicated.dval)\n    val isa Union{Array, SplineGrid} && make_zero!(val)\nend\nautodiff(\n    Reverse,\n    loss_from_grid,\n    Active,\n    meta_p.render_duplicated,\n    Duplicated(p_render.u, meta_p.p_render_duplicated.dval.u),\n    Duplicated(p_render.∂₁u, meta_p.p_render_duplicated.dval.∂₁u),\n    Duplicated(p_render.∂₂u, meta_p.p_render_duplicated.dval.∂₂u),\n    Duplicated(spline_grid, meta_p.p_render_duplicated.dval.spline_grid),\n    Const(target),\n    Const(p_render)\n)\n\nheatmap(\n    abs.(meta_p.p_render_duplicated.dval.∂₁u[:,:,1]) +\n    abs.(meta_p.p_render_duplicated.dval.∂₂u[:,:,1]), \n    aspect_ratio=:equal)","category":"page"},{"location":"#SplineGrids.jl","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"","category":"section"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"SplineGrids.jl is designed to efficiently evaluate a broad class of spline objects on a grid in the spline's domain. The package supports:","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"Any number of input and output dimensions (see the examples here)\nAny degree of basis functions and type of knot vector\nAny combination of partial derivatives\nUsing weights to define NURBS (coming up)\nLocal refinement (coming up)\nCPU and GPU backends via KernelAbstractions.jl","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"The intended use case of this package is to be integrated into the SciML ecosystem, for easy and efficient incorporation of spline geometries in problems of fitting, optimization, differential equation solving and machine learning. Since SplineGrids.jl makes heavy use of in-place computations, the recommended automatic differentiation framework to use with SplineGrids.jl is Enzyme.","category":"page"},{"location":"#API","page":"SplineGrids.jl","title":"API","text":"","category":"section"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"using SplineGrids\n\n# Parameters per input dimension\nn_control_points = (10, 10, 5)\ndegree = (2, 3, 2)\nn_sample_points = (50, 50, 25)\n\n# The number of output dimensions\nNout = 4\n\n# Defining the spline grid\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, Nout)\n\n# Set the desired control points\nspline_grid.control_points .= rand(n_control_points..., Nout)\n\n# Evaluate\nevaluate!(spline_grid)\n\n# The output can be found in spline_grid.eval of shape (n_sample_points..., Nout)","category":"page"},{"location":"#History-and-theory","page":"SplineGrids.jl","title":"History and theory","text":"","category":"section"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"The most well known introduction to spline theory is probably The NURBS book [1].","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"SplineGrids.jl was inspired by work on caustic design by optimizing spline-based lens surfaces with differentiable ray tracing. This work was published in a master thesis and later in follow-up research [2][3][4].","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"Some of the core ideas for this package where implemented earlier in NURBS Pytorch, but that package was never properly tested or released.","category":"page"},{"location":"#References","page":"SplineGrids.jl","title":"References","text":"","category":"section"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"[1] Piegl, L., & Tiller, W. (2012). The NURBS book. Springer Science & Business Media.","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"[2] Koning, B. D., Heemels, A., Adam, A., & Möller, M. (2024). Gradient descent-based freeform optics design for illumination using algorithmic differentiable non-sequential ray tracing. Optimization and Engineering, 25(3), 1203-1235.","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"[3] Heemels, A., De Koning, B., Möller, M., & Adam, A. (2024). Optimizing freeform lenses for extended sources with algorithmic differentiable ray tracing and truncated hierarchical B-splines. Optics Express, 32(6), 9730-9746.","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"[4] Heemels, A., de Koning, B., Moller, M., & Adama, A. (2024, May). Unsupervised design of illumination optics using algorithmic differentiable raytracing. In International Optical Design Conference 2023 (Vol. 12798, pp. 84-85). SPIE.","category":"page"}]
}

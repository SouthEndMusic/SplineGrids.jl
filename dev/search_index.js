var documenterSearchIndex = {"docs":
[{"location":"theory_local_refinement/#Local-refinement","page":"Local refinement (THB-splines)","title":"Local refinement","text":"","category":"section"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"As we have seen in the previous section (Refinement), The number of control points can be increased without changing the geometry by using refinement matrices. The key concepts of local refinement are as follows:","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"Set up a base grid of control points\nExtend the control point grid using refinement matrices\nOverwrite certain control points in one of the intermediate extended grids","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"note: Understanding THB splines\nTHB-splines can be a tricky construct to understand when you encounter them for the first time. This page does not aim to give a full theoretical background, that can be for instance found in [1]. Playing around with THB-splines in the context of this package might however give you intuition for them more quickly than reading the theory.","category":"page"},{"location":"theory_local_refinement/#An-example","page":"Local refinement (THB-splines)","title":"An example","text":"","category":"section"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"Local refinement is probably best understood using an example. We use a surface here, because local refinement of curves is trivial.","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"We create a surface, and have a look at its basis functions.","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"using SplineGrids\nusing CairoMakie\n\nn_control_points = (6, 6)\ndegree = (2, 2)\nn_sample_points = (500, 500)\ndim_out = 3\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nplot_basis(spline_grid)","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"This basis looks rather 'Cartesian', and knot insertion can only refine the basis in whole rows and columns. So what we do is set up refinement matrices for both dimensions, use some of the old basis functions and use some of the new ones.","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"# Set up `LocallyRefinedControlPoints` with a refinement matrix for both dimensions\nspline_grid = add_default_local_refinement(spline_grid)","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"# Activate control point ranges (by default in the last extended control point grid).\n# Note that some of these ranges overlap, this is fine and no duplicate control points are created\nactivate_local_control_point_range!(spline_grid, 1:4, 1:6)\nactivate_local_control_point_range!(spline_grid, 1:6, 1:2)\nactivate_local_control_point_range!(spline_grid, 9:10, 7:10)\ndeactivate_overwritten_control_points!(spline_grid.control_points)\nplot_basis(spline_grid)","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"Note that some of the original basis functions are completely gone, which means that their contribution to the final geometry is completely overwritten. The function deactivate_overwritten_control_points! weeds out the control points associated with these overwritten basis functions. This means that every active control point is guaranteed to influence the spline geometry (assuming there is at least one global sample point in the effective support of the basis function associated with that control point).","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"A nice property of this construction is that it can be iterated, creating a hierarchy. Let's refine the basis some more:","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"spline_grid = add_default_local_refinement(spline_grid)","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"activate_local_control_point_range!(spline_grid, 5:12, 1:4)\nactivate_local_control_point_range!(spline_grid, 7:8, 5:6)\ndeactivate_overwritten_control_points!(spline_grid.control_points)\nplot_basis(spline_grid)","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"This is in fact an exact reproduction of the THB-spline example shown in [1] (p. 6).","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"Finally, let's give the z-coordinates of the control points some random values and look at the surface.","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"using Plots\nusing Random\nRandom.seed!(42)\n\nspline_grid.control_points[:, 3] .= rand(Float32, get_n_control_points(spline_grid))\nevaluate!(spline_grid.control_points)\nevaluate!(spline_grid)\np = Plots.plot(spline_grid, camera = (30, 60, 1.5))\nPlots.zlims!(p, 0, 1)","category":"page"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"See Local refinement informed by local error for an example of how a local fitting error can be used to inform where to refine.","category":"page"},{"location":"theory_local_refinement/#References","page":"Local refinement (THB-splines)","title":"References","text":"","category":"section"},{"location":"theory_local_refinement/","page":"Local refinement (THB-splines)","title":"Local refinement (THB-splines)","text":"[1] Giannelli, C., Jüttler, B., Kleiss, S. K., Mantzaflaris, A., Simeon, B., & Špeh, J. (2016). THB-splines: An effective mathematical technology for adaptive refinement in geometric design and isogeometric analysis. Computer Methods in Applied Mechanics and Engineering, 299, 337-365.","category":"page"},{"location":"examples_enzyme/#Enzyme-example","page":"Control point derivatives with Enzyme","title":"Enzyme example","text":"","category":"section"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"To demonstrate how Enzyme can be used to incorporate a spline grid into an optimization pipeline, we show what the derivative of a spline grid with respect to one control point looks like.","category":"page"},{"location":"examples_enzyme/#Defining-the-spline-grid","page":"Control point derivatives with Enzyme","title":"Defining the spline grid","text":"","category":"section"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"We define a spline grid with 2 input dimensions and 1 output dimension.","category":"page"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"using SplineGrids\n\nn_control_points = (10, 10)\ndegree = (2, 2)\nn_sample_points = (100, 100)\ndim_out = 1\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid.control_points .= 0\nspline_grid","category":"page"},{"location":"examples_enzyme/#Gradient-demonstration","page":"Control point derivatives with Enzyme","title":"Gradient demonstration","text":"","category":"section"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"Here we show what the gradient of the output surface with respect to one control point looks like.","category":"page"},{"location":"examples_enzyme/","page":"Control point derivatives with Enzyme","title":"Control point derivatives with Enzyme","text":"using Enzyme\nusing Plots\n\ndspline_grid = deepcopy(spline_grid)\ndspline_grid.control_points[5, 5] = 1\n\nout = autodiff(Forward, Duplicated(spline_grid, dspline_grid)) do spline_grid\n    evaluate!(spline_grid)\n    spline_grid.eval\nend\n\nheatmap(out[1][:, :, 1])","category":"page"},{"location":"theory_refinement/#Refinement","page":"Refinement","title":"Refinement","text":"","category":"section"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"The geometric operations discussed here are based on the following observation: When a knot is added to a knot vector, the basis functions defined on the original knot vector can be expressed as a linear combination of the basis functions defined on the new knot vector. This can be used to insert knots and with that new control points while the resulting spline geometry stays the same.","category":"page"},{"location":"theory_refinement/#Knot-insertion","page":"Refinement","title":"Knot insertion","text":"","category":"section"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"When a single knot is added to a knot vector this is called knot insertion. Let's have a look at what happens when we add a single knot.","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"using SplineGrids\nusing Random\nusing Plots\n\nRandom.seed!(2)\n\nn_control_points = 8\ndegree = 2\nn_sample_points = 500\nNout = 2\n\nspline_dimension = SplineDimension(\n    n_control_points, degree, n_sample_points; distribution = :random)\nspline_grid = SplineGrid(spline_dimension, Nout)\nfor (i, θ) in enumerate(range(3π, 0, length = n_control_points))\n    r = 2θ\n    spline_grid.control_points[i, 1] = r * cos(θ)\n    spline_grid.control_points[i, 2] = r * sin(θ)\nend\n\nplot(spline_dimension, title = \"Original basis\", legend = :topright)","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"spline_grid_new = deepcopy(spline_grid)\nspline_grid_new, refinement_matrix = insert_knot(spline_grid_new, 1, 0.25)\nspline_dimension_new = only(spline_grid_new.spline_dimensions)\nplot(spline_dimension_new, title = \"Basis after knot insertion\", legend = :topright)","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"Using the refinement matrix, we can for instance express the original basis function 3 in terms of the new basis functions 3 and 4.","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"data = decompress(spline_dimension)\ndata_new = decompress(spline_dimension_new)\n\n(; sample_points) = spline_dimension\nplot(sample_points, data[:, 3], label = \"Original basis function 3\")\nplot!(sample_points, refinement_matrix[3, 3] * data_new[:, 3],\n    label = \"Scaled new basis function 3\", ls = :dash)\nplot!(sample_points, refinement_matrix[4, 3] * data_new[:, 4],\n    label = \"Scaled new basis function 4\", ls = :dash)\nylims!(0, 1)","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"If we define a curve in mathbbR^2 with these bases, the refinement looks like this.","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"evaluate!(spline_grid)\nplot(spline_grid, title = \"Curve with original basis\")\nxlims!(-20, 15)\nylims!(-10, 20)","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"evaluate!(spline_grid_new)\nplot(spline_grid_new, title = \"Curve with basis after knot insertion\")\nxlims!(-20, 15)\nylims!(-10, 20)","category":"page"},{"location":"theory_refinement/#Knot-refinement","page":"Refinement","title":"Knot refinement","text":"","category":"section"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"We can also add multiple knots at a time, which is called knot refinement. A set of new knots can be supplied, but the default refinement behavior is to bisect each (non trivial) knot span.","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"spline_grid_new, refinement_matrix = refine(spline_grid_new, 1)\nevaluate!(spline_grid_new)\nplot(spline_grid_new; title = \"Curve with basis after knot refinement\")\nxlims!(-20, 15)\nylims!(-10, 20)","category":"page"},{"location":"theory_refinement/#The-refinement-matrix","page":"Refinement","title":"The refinement matrix","text":"","category":"section"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"The linear combinations that express the old basis functions in terms of the new ones can be combined into a refinement matrix R. This matrix can be used to express the new control points mathbfQ in terms of the old control points mathbfP:","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"$","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"\\mathbf{Q} = \\mathbf{P} \\otimes_n R $","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"where otimes_n is the n-th mode tensor product, where n is the input dimension that was refined.","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"The matrix R is sparse with a particular pattern: the non-zeros in each row and column are consecutive, and each row and column has at least one non-zero. This is taken advantage of with a specialized sparse matrix encoding for efficient multiplications. For more details on this see the manual section on Structs.","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"For the knot refinement performed above the refinement matrix looks like this:","category":"page"},{"location":"theory_refinement/","page":"Refinement","title":"Refinement","text":"heatmap(collect(refinement_matrix)[end:-1:1, :])","category":"page"},{"location":"examples_linear_fitting/#Linear-fitting-example","page":"Linear fitting","title":"Linear fitting example","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"In this section we demonstrate how a spline grid can be fitted. We will fit a spline surface to the following image.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using Images\nimage = load(normpath(@__DIR__, \"julia_logo.png\"))","category":"page"},{"location":"examples_linear_fitting/#Defining-the-spline-grid","page":"Linear fitting","title":"Defining the spline grid","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"We define a spline grid with 2 input dimensions, 1 output dimension and a sample grid which matches the image resolution.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using SplineGrids\n\ndegree = (2, 2)\nimage_array = Float32.(Gray.(image[end:-1:1, :]))'\nn_sample_points = size(image_array)\nn_control_points = ntuple(i -> n_sample_points[i]÷10, 2)\ndim_out = 1\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid","category":"page"},{"location":"examples_linear_fitting/#Fitting","page":"Linear fitting","title":"Fitting","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"We fit the spline surface to the image in a least squares sense, by interpreting the spline grid evaluation as a linear mapping.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using LinearMaps\nusing IterativeSolvers\nusing Plots\n\nspline_grid_map = LinearMap(spline_grid)\nsol = lsqr(spline_grid_map, vec(image_array))\nspline_grid.control_points .= reshape(sol, size(spline_grid.control_points))\nevaluate!(spline_grid)\nplot(spline_grid)","category":"page"},{"location":"examples_linear_fitting/#Matrix","page":"Linear fitting","title":"Matrix","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"The least-squares fitting procedure above is matrix free, but the linear mapping can be converted into a (sparse) matrix for inspection.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using SparseArrays\n\nn_control_points = (5, 5)\ndegree = (2, 2)\nn_sample_points = (15, 15)\ndim_out = 1\n\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid_ = SplineGrid(spline_dimensions, dim_out)\nspline_grid_map = LinearMap(spline_grid_)\nM = sparse(spline_grid_map)\nheatmap(M[end:-1:1,:])","category":"page"},{"location":"examples_linear_fitting/#Local-refinement-informed-by-local-error","page":"Linear fitting","title":"Local refinement informed by local error","text":"","category":"section"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"Clearly the error of the fit is largest around the boundary of the text:","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"err = (spline_grid.eval - image_array).^2\nheatmap(err[:,:,1]', colormap =  c=cgrad(:RdYlGn, rev=true))\ntitle!(\"Squared error per pixel\")","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"We can easily locally refine the spline basis by mapping this error back on to the control points.","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"using CairoMakie\n\nspline_grid = add_default_local_refinement(spline_grid)\nerror_informed_local_refinement!(spline_grid, err)\ndeactivate_overwritten_control_points!(spline_grid.control_points)\nplot_basis(spline_grid)","category":"page"},{"location":"examples_linear_fitting/","page":"Linear fitting","title":"Linear fitting","text":"We can now fit the image again with the refined basis (coming up).","category":"page"},{"location":"manual/#Constructors","page":"Manual","title":"Constructors","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"KnotVector(::Integer, ::Integer)\nSplineDimension(::Integer, ::Integer, ::Integer)\nSplineGrid(::NTuple{Nin, <:SplineDimension{Tv, Ti}}, ::Integer) where {Nin, Tv, Ti}\nNURBSGrid\nrmeye\nRefinementMatrix(::SplineDimension{Tv, Ti}, ::Integer, ::Any) where {Tv, Ti <: Integer}","category":"page"},{"location":"manual/#SplineGrids.KnotVector-Tuple{Integer, Integer}","page":"Manual","title":"SplineGrids.KnotVector","text":"KnotVector(\n    n_basis_functions::Integer, \n    degree::Integer; \n    extent::Tuple{Number, Number} = (0,1), \n    distribution::Symbol = :equispaced)\n\nConstruct a clamped knot vector, i.e. the multiplicity of the first and last knot is degree + 1 and the other multiplicities are 1.\n\nArguments\n\nn_basis_functions: The number of basis functions that will be defined on this knot vector\ndegree: The degree of the basis functions that will be defined on this knot vector\n\nKeyword Arguments\n\nextent: A tuple (tmin, tmax) defining the extend of the knot vector\ndistribution: The distribution of the internal knots. The options are :equispaced or :random\nbackend: The KernelAbstractions backend of the arrays in the object. Defaults to CPU().\nfloat_type: The type of all floating point arrays. Defaults to Float32.\nint_type: The type of all integer arrays. Defaults to Int32.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.SplineDimension-Tuple{Integer, Integer, Integer}","page":"Manual","title":"SplineGrids.SplineDimension","text":"SplineDimension(\n    n_basis_functions::Integer,\n    degree::Integer,\n    n_sample_points::Integer;\n    max_derivative_order::Integer = 0,\n    knot_vector::Union{Nothing, KnotVector{Tv, Ti}} = nothing,\n    backend::Backend = CPU(),\n    float_type::Type{Tv} = Float32,\n    int_type::Type{Ti} = Int32,\n    kwargs...)::SplineDimension where {Tv <: AbstractFloat, Ti <: Integer}\n\nConstructor for a SplineDimension. Optionally a knot_vector kwarg can be passed, otherwise a default knot vector is generated. For now by default the sample points are evenly spaced on the extent of the knot vector. Key word arguments are passed to the KnotVector constructor.\n\nInputs\n\nn_basis_functions: The number of basis functions of this spline dimension\ndegree: The degree of the basis functions of this spline dimension\nn_sample_points: The number of points at which the domain of the basis functions will be sampled\nmax_derivative_order: The maximum derivative order of the basis functions that will be computed in evaluate!. Defaults to 0. knot_vector: A knot vector on which the basis functions will be defined. Defaults to nothing, which means that a default clamped/open equally spaced knot vector will be defined.\nbackend: The KernelAbstractions backend of the arrays in the object. Defaults to CPU(). NOTE: If a knot vector is supplied, its backend takes precedence.\nfloat_type: The type of all floating point arrays. Defaults to Float32.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.SplineGrid-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nin}, Tuple{NTuple{Nin, var\"#s26\"} where var\"#s26\"<:(SplineDimension{Tv, Ti, K, S, I, E} where {K<:(KnotVector{Tv, Ti, K, M} where {K<:AbstractVector{Tv}, M<:AbstractVector{Ti}}), S<:AbstractVector{Tv}, I<:AbstractVector{Ti}, E<:AbstractArray{Tv, 3}}), Integer}} where {Nin, Tv, Ti}","page":"Manual","title":"SplineGrids.SplineGrid","text":"SplineGrid(spline_dimensions::NTuple{Nin, <:SplineDimension{Tv, Ti}}, Nout::Integer)::SplineGrid{Nin, Tv, Ti} where {Nin, Tv, Ti}\n\nDefine a SplineGrid from an NTuple of spline dimensions and the number of output dimensions.\n\nInputs\n\nspline_dimensions: an NTuple of spline dimensions\nNout: The number of output dimensions. I.e. the control points and thus the spline live in ℝ^Nout.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.NURBSGrid","page":"Manual","title":"SplineGrids.NURBSGrid","text":"Create a SplineGrid but with preallocated weights to define a NURBS. See The SplineGrid constructors for more details.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SplineGrids.rmeye","page":"Manual","title":"SplineGrids.rmeye","text":"rmeye(\n    n::Integer;\n    backend::Backend = CPU(),\n    float_type::Type{Tv} = Float32,\n    int_type::Type{Ti} = Int)::RefinementMatrix{Tv, Ti} where {Tv, Ti <: Integer}\n\nConstruct an identity refinement matrix.\n\nInput\n\nn: The size of the identity matrix is n×n\nbackend: The KernelAbstractions backend of the matrix data\nfloat_type: The value type of the matrix data\nint_type: The integer type of the matrix data\n\n\n\n\n\n","category":"function"},{"location":"manual/#SplineGrids.RefinementMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K<:(KnotVector{Tv, Ti, K, M} where {K<:AbstractVector{Tv}, M<:AbstractVector{Ti}}), S<:AbstractVector{Tv}, I<:AbstractVector{Ti}, E<:AbstractArray{Tv, 3}}, Integer, Any}} where {Tv, Ti<:Integer}","page":"Manual","title":"SplineGrids.RefinementMatrix","text":"RefinementMatrix(\n    spline_dimension::SplineDimension{Tv, Ti},\n    knot_span_index::Integer,\n    knot_new\n    )::RefinementMatrix{Tv, Ti} where {Tv, Ti <: Integer}\n\nBuild a refinement matrix per row given a knot vector and a to be added new knot.\n\nInputs\n\nspline_dimension: The spline dimension whose knot vector the new knot is to be added to\nknot_span_index: The index such that knots_all[knot_span_index] ≤ knot_new < knots_all[knot_span_index + 1]\nknot_new: The value of the new knot\n\n\n\n\n\n","category":"method"},{"location":"manual/#Evaluation","page":"Manual","title":"Evaluation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"evaluate!(::SplineDimension)\nevaluate!(::SplineGrids.AbstractSplineGrid{Nin, Nout, false}) where {Nin, Nout}\nevaluate!(::SplineGrids.AbstractNURBSGrid{Nin}) where {Nin}\nevaluate_adjoint!\nmult!\nevaluate!(::LocallyRefinedControlPoints)","category":"page"},{"location":"manual/#SplineGrids.evaluate!-Tuple{SplineDimension}","page":"Manual","title":"SplineGrids.evaluate!","text":"evaluate!(spline_dimension)\n\nPer sample point, get the value of the spline_dimension.degree + 1 basis functions that have a non-zero value for that sample point. This is based on the Cox-de Boor recursion formula.\n\nThe l-th sample point t has sample index i, meaning that t ∈ [tᵢ, tᵢ₊₁). Therefore Bᵢ₀(t) = 1, Bⱼ₀(t) = 0 for j ≠ i. For degree k, t is in the domain of Bⱼₖ which is [tⱼ, tⱼ₊ₖ₊₁), for j = i - k, ..., i.\n\nArguments\n\nspline_dimension\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false}}, Tuple{Nout}, Tuple{Nin}} where {Nin, Nout}","page":"Manual","title":"SplineGrids.evaluate!","text":"evaluate!(spline_grid::SplineGrid{Nin};\n    derivative_order::NTuple{Nin, <:Integer} = ntuple(_ -> 0, Nin),\n    control_points::AbstractArray = spline_grid.control_points,\n    eval::AbstractArray = spline_grid.eval)\n\nEvaluate the spline grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a linear combination of control points with basis function products as coefficients.\n\nIf weights are supplied, compute the rational basis functions for NURBS as the control point coefficients.\n\nUses the control_points and eval arrays from the spline_grid by default, but different arrays can be specified as a convenience for optimization algorithms.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.evaluate!-Union{Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, true, Tv, Ti} where {Nout, Tv, Ti}}, Tuple{Nin}} where Nin","page":"Manual","title":"SplineGrids.evaluate!","text":"evaluate!(spline_grid::SplineGrid{Nin};\n    derivative_order::NTuple{Nin, <:Integer} = ntuple(_ -> 0, Nin),\n    control_points::AbstractArray = spline_grid.control_points,\n    eval::AbstractArray = spline_grid.eval)\n\nEvaluate the spline grid, that is: take the evaluated basis functions for each sample point for each SplineDimension, and compute the output grid on each sample point combination as a linear combination of control points with basis function products as coefficients.\n\nIf weights are supplied, compute the rational basis functions for NURBS as the control point coefficients.\n\nUses the control_points and eval arrays from the spline_grid by default, but different arrays can be specified as a convenience for optimization algorithms.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.evaluate_adjoint!","page":"Manual","title":"SplineGrids.evaluate_adjoint!","text":"evaluate_adjoint!(spline_grid::AbstractSplineGrid{Nin, Nout, false, Tv};\n    derivative_order::NTuple{Nin, <:Integer} = ntuple(_ -> 0, Nin),\n    control_points::AbstractControlPointArray{Nin, Nout, Tv} = spline_grid.control_points,\n    eval::AbstractArray = spline_grid.eval)::Nothing where {Nin, Nout, Tv}\n\nevaluate the adjoint of the linear mapping control_points -> eval. This is a computation of the form eval -> control_points. If we write evaluate!(spline_grid) as a matrix vector multiplication eval = M * control_points, Then the adjoint is given by v -> M' * v. This mapping is used in fitting algorithms.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SplineGrids.mult!","page":"Manual","title":"SplineGrids.mult!","text":"mult!(\n    Y::V,\n    As::NTuple{<:RefinementMatrix{Tv}, N},\n    B::V,\n    dims_refinement::NTuple{<:Integer, N})::Nothing where {Tv, V <: AbstractArray{Tv}, N}\n\n'left-multiply' the array B by every refinement matrix along the specified dimension.\n\nInputs\n\nY: The target array of the multiplication\nAs: The refinement matrices Y will be multiplied by\nB: The array that will be multiplied by the refinement matrices\ndims_refinement: The dimension along which the refinement matrix multiplication will take place for each matrix\n\n\n\n\n\n","category":"function"},{"location":"manual/#SplineGrids.evaluate!-Tuple{LocallyRefinedControlPoints}","page":"Manual","title":"SplineGrids.evaluate!","text":"Evaluate the locally refined control points. For each local refinement, first apply the refinement matrix and then overwrite the desired control point values.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Geometric-operations","page":"Manual","title":"Geometric operations","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"insert_knot(::KnotVector, ::AbstractFloat)\ninsert_knot(::SplineDimension{Tv, Ti}, ::AbstractFloat) where {Tv, Ti}\ninsert_knot(::A, ::Integer, ::AbstractFloat) where {A <: SplineGrids.AbstractSplineGrid}\nrefine(::SplineDimension{Tv, Ti}) where {Tv, Ti}\nrefine(::A, ::Integer) where {A <: SplineGrids.AbstractSplineGrid}\nrefine(::SplineGrids.AbstractSplineGrid{Nin, Nout, false, Tv, Ti}, ::SplineDimension{Tv, Ti}, ::Integer, ::RefinementMatrix{Tv, Ti}) where {Nin, Nout, Tv, Ti}\nactivate_local_refinement!(\n        ::LocallyRefinedControlPoints{Nin, Nout, Tv, Ti},\n        ::AbstractMatrix{Ti}) where {Nin, Nout, Tv, Ti}\nactivate_local_refinement!(::SplineGrids.AbstractSplineGrid, args...)\nactivate_local_control_point_range!\nerror_informed_local_refinement!\ndeactivate_overwritten_control_points!(::LocallyRefinedControlPoints)\ndeactivate_overwritten_control_points!(::LocallyRefinedControlPoints, ::Integer)","category":"page"},{"location":"manual/#SplineGrids.insert_knot-Tuple{KnotVector, AbstractFloat}","page":"Manual","title":"SplineGrids.insert_knot","text":"insert_knot(\nknot_vector::KnotVector, \nknot_new::AbstractFloat)::Tuple{KnotVector, Integer}\n\nCreate a new knot vector with the new knot of multiplicity 1.\n\nInputs\n\nknot_vector: The knot vector object to which the knot will be added\nknot_new: The value of the new knot. Should not be part of the knot values already\n\nOutputs\n\nknot_vector_new: The newly created knot vector with the added knot\nknot_span_index: The index such that knots_all[knot_span_index] ≤ knot_new < knots_all[knot_span_index + 1]\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.insert_knot-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K<:(KnotVector{Tv, Ti, K, M} where {K<:AbstractVector{Tv}, M<:AbstractVector{Ti}}), S<:AbstractVector{Tv}, I<:AbstractVector{Ti}, E<:AbstractArray{Tv, 3}}, AbstractFloat}} where {Tv, Ti}","page":"Manual","title":"SplineGrids.insert_knot","text":"insert_knot(\n    spline_dimension::SplineDimension{Tv, Ti},\n    knot_new::AbstractFloat;\n    recompute_sample_indices::Bool = true,\n    evaluate::Bool = true)::Tuple{\n        SplineDimension{Tv, Ti},\n        RefinementMatrix{Tv, Ti}\n    } where {Tv, Ti}\n\nCreate a new spline dimension whose knot vector has the new knot with multiplicity 1.\n\nInputs\n\nspline_dimension: The spline dimension the new knot will be added to\nknot_new: The value of the new knot\nrecompute_sample_indices: Whether the indices of the sample points should be recomputed after the knot insertion. Defaults to true.\nevaluate: Whether the spline dimension should be evaluated after the knot insertion. Defaults to true.\n\nOutputs\n\nspline_dimension_new: The newly created spline dimension with the same underlying memory except for the new knot vector.\nrefinement_matrix: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.insert_knot-Union{Tuple{A}, Tuple{A, Integer, AbstractFloat}} where A<:SplineGrids.AbstractSplineGrid","page":"Manual","title":"SplineGrids.insert_knot","text":"insert_knot(\n    spline_grid::A,\n    dim_refinement::Integer,\n    knot_new::AbstractFloat;\n    evaluate_spline_dimension::Bool = true)::Tuple{A, RefinementMatrix} where {A <: AbstractSplineGrid}\n\nCreate a new spline grid where a new knot is added to the knot vector underlying the indicated spline dimension.\n\nInputs\n\nspline_grid: The spline grid to which the new knot will be added\nknot_new: The value of the knot to be added\ndim_refinement: The index of the spline dimension to which the knot will be added\nevaluate_spline_dimension: Whether the spline dimension to which the knot is added should be evaluated. Defaults to true.\n\nOutputs\n\nspline_grid_new: The newly created spline grid with all the same underlying memory except for the updated knot vector and the control points.\nrefinement_matrix: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion for the knot insertion dimension.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.refine-Union{Tuple{SplineDimension{Tv, Ti, K, S, I, E} where {K<:(KnotVector{Tv, Ti, K, M} where {K<:AbstractVector{Tv}, M<:AbstractVector{Ti}}), S<:AbstractVector{Tv}, I<:AbstractVector{Ti}, E<:AbstractArray{Tv, 3}}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Manual","title":"SplineGrids.refine","text":"refine(\n    spline_dimension::SplineDimension{Tv, Ti};\n    knots_new::Union{Vector{<:AbstractFloat}, Nothing} = nothing)::Tuple{SplineDimension{Tv, Ti}, RefinementMatrix{Tv, Ti}} where {Tv, Ti}\n\nCreate a new spline dimension with multiple knots added to the underlying knot vector.\n\nInputs\n\nspline_dimension: The spline dimension the new knots will be added to\nknots_new: The vector of knots that will be added. Defaults to the midpoints of the knot spans of the vector underlying the spline dimension.\n\nOutputs\n\nspline_dimension_new: The newly created spline dimension with the same underlying memory except for the new knot vector.\nrefinement_matrix: The sparse matrix which expresses the basis functions from before the refinement in terms of the basis functions after the refinement.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.refine-Union{Tuple{A}, Tuple{A, Integer}} where A<:SplineGrids.AbstractSplineGrid","page":"Manual","title":"SplineGrids.refine","text":"refine(\n    spline_grid::A,\n    dim_refinement::Integer;\n    knots_new::Union{AbstractVector{<:AbstractFloat}, Nothing} = nothing)::Tuple{A, RefinementMatrix} where {A <: AbstractSplineGrid}\n\nCreate a new spline grid where multiple knots are added to the knot vector underlying the indicated spline dimension.\n\nInputs\n\nspline_grid: The spline grid from which one of the knot vectors will be refined\ndim_refinement: The index of the spline dimension whose knot vector will be refined\nknots_new: The knots that will be added. Defaults to nothing, which internally is translated to all midpoints of the non-trivial knot spans of the knot vector that will be refined.\n\nOutputs\n\nspline_grid_new: The newly created spline grid with all the same underlying memory except for the updated knot vector and the control points.\nrefinement_matrix: The sparse matrix which expresses the basis functions from before the knot insertion in terms of the basis functions after the knot insertion for the knot insertion dimension.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.refine-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{SplineGrids.AbstractSplineGrid{Nin, Nout, false, Tv, Ti}, SplineDimension{Tv, Ti, K, S, I, E} where {K<:(KnotVector{Tv, Ti, K, M} where {K<:AbstractVector{Tv}, M<:AbstractVector{Ti}}), S<:AbstractVector{Tv}, I<:AbstractVector{Ti}, E<:AbstractArray{Tv, 3}}, Integer, RefinementMatrix{Tv, Ti}}} where {Nin, Nout, Tv, Ti}","page":"Manual","title":"SplineGrids.refine","text":"refine(\n    spline_grid::AbstractSplineGrid{Nin, Nout, false, Tv, Ti},\n    spline_dimension_new::SplineDimension{Tv, Ti},\n    dim_refinement::Integer,\n    refinement_matrix::RefinementMatrix{Tv, Ti} where {Nin, Nout, Tv, Ti}\n\nUpdate the spline grid with a refined spline dimension in the specified dimension with the associated refinement matrix.\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.activate_local_refinement!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Nout}, Tuple{Nin}, Tuple{LocallyRefinedControlPoints{Nin, Nout, Tv, Ti, V, L} where {V<:(AbstractArray{Tv}), L<:(LocalRefinement{Nin, Nout, Tv, Ti, R, I, D} where {R<:RefinementMatrix, I<:AbstractMatrix{Ti}, D<:AbstractMatrix{Tv}})}, AbstractMatrix{Ti}}} where {Nin, Nout, Tv, Ti}","page":"Manual","title":"SplineGrids.activate_local_refinement!","text":"Given a refinement step (by default the last refinement), add new control points that overwrite the result from the refinement matrix. These new values are chosen such that the spline geometry does not change.\n\nInputs\n\ncontrol_points: The locally refined control points where new control points will be activated\nrefinement_indices: The indices in the control point grid at the refinement_index level which will be overwritten\nrefinement_index: The index of the refinement after which new control points will be activated\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.activate_local_refinement!-Tuple{SplineGrids.AbstractSplineGrid, Vararg{Any}}","page":"Manual","title":"SplineGrids.activate_local_refinement!","text":"Convenience wrapper of activate_local_refinement! for a spline grid\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.activate_local_control_point_range!","page":"Manual","title":"SplineGrids.activate_local_control_point_range!","text":"Instead of supplying explicit indices of the control points for local refinement activation, supply a range of indices per dimension.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SplineGrids.error_informed_local_refinement!","page":"Manual","title":"SplineGrids.error_informed_local_refinement!","text":"error_informed_local_refinement!(\n    spline_grid::AbstractSplineGrid{Nin, Nout, HasWeights, Tv, Ti},\n    error::AbstractArray;\n    threshold::Union{Number, Nothing} = nothing\n    )::Nothing where {Nin, Nout, HasWeights, Tv, Ti}\n\nRefine the last level of the locally refined spline grid informed by the error array which has the same shape as spline_grid.eval. This is done by:\n\nmapping the error back onto the control points by using the adjoint of the refinement matrices multiplication\nsumming over the output dimensions to obtain a single number per control point stored in control_grid_error\nactivating each control point whose value is bigger than threshold\n\nthreshold can be explicitly provided but by default it is given by the mean of control_grid_error.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SplineGrids.deactivate_overwritten_control_points!-Tuple{LocallyRefinedControlPoints}","page":"Manual","title":"SplineGrids.deactivate_overwritten_control_points!","text":"Perform deactivate_control_points for every refinement level except the last one in reverse order. For more details see deactivate_overwritten_control_points!(::LocallyRefinedControlPoints, ::Integer).\n\n\n\n\n\n","category":"method"},{"location":"manual/#SplineGrids.deactivate_overwritten_control_points!-Tuple{LocallyRefinedControlPoints, Integer}","page":"Manual","title":"SplineGrids.deactivate_overwritten_control_points!","text":"deactivate_overwritten_control_points!(\n    control_points::LocallyRefinedControlPoints,\n    local_refinement_level::Integer)::Nothing\n\nDeactivate control points whose effect is completely overwritten. The procedure works as follows:\n\nThe 'forward' computation to process local refinement is as follows:\n\nB = (O₂ ∘ L ∘ O₁)(A),\n\nwhere:\n\nA is the control point grid at local_refinement_level\nB is the control point grid at local_refinement_level + 1\nO₁ is the overwriting operation of the active control points at local_refinement_level\nL is the linear operation consisting of multiplying by refinement matrices along specified dimensions\nO₂ is the overwriting operation of the active control points at local_refinement_level + 1\n\nTo figure out whether for any overwriting element of O₁ its effect is still present in the final array, we perform the following computation:\n\nA = (L* ∘ O₂)(B),\n\nwhere:\n\nB is initialized with a special number Flag, which is a simple wrapper of a Boolean effectively saying whether this number is relevant or not. B is initialized with all Flag(true)\nThe overwriting values of O₂ are initialized with all Flag(false)\nL* is the adjoint version of L\n\nAfter this computation we can read of in A at the overwriting locations of O₁ whether each number is still having an effect on B or not.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Structs","page":"Manual","title":"Structs","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"KnotVector\nSplineDimension\nRefinementMatrix\nDefaultControlPoints\nLocalRefinement\nLocallyRefinedControlPoints\nSplineGrid","category":"page"},{"location":"manual/#SplineGrids.KnotVector","page":"Manual","title":"SplineGrids.KnotVector","text":"KnotVector(knots, multiplicities)\n\nDefines a knot vector.\n\nArguments\n\nknot_values: The values in the knot vector. Must be strictly increasing.\nmultiplicities: The multiplicity of each knot in knots.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SplineGrids.SplineDimension","page":"Manual","title":"SplineGrids.SplineDimension","text":"SplineDimension(\n    degree, \n    max_derivative_order, \n    knot_vector, \n    sample_points, \n    sample_indices, \n    eval, \n    eval_prev)\n\nDefines the set of basis functions for a single dimension, and how it is sampled.\n\nArguments\n\ndegree: The degree of the piecewise polynomial basis functions.\nmax_derivative_order: The maximum derivative order of the basis functions that will be computed.\nknot_vector: The knot vector on which the basis functions are defined.\nsample_points: The points in the domain of the basis functions where they are sampled. Must\nlie within the boundaries of the knot vector.\nsample_indices: The indices i of the sample points t in the knot vector such that knot_vector.knots[i] ≤ t < knot_vector.knots[i + 1]`\neval: An array of shape (length(sample_points), degree + 1, max_derivative + 1), with per sample point the values of those basis functions\neval_prev: Helper array for intermediate results in the basis function computations whose support the sample point is in, and the derivatives if requested.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SplineGrids.RefinementMatrix","page":"Manual","title":"SplineGrids.RefinementMatrix","text":"RefinementMatrix(m, n, row_pointer, column_start, nzval)\n\nThe refinement matrix is a sparse matrix encoding for matrices which:\n\nHave consecutive non-zeros in all rows and columns\nHave at least 1 nonzero in every row and column\n\nThe non-zeros are stored in a dense vector per row.\n\nFields\n\nm: The number of rows of the matrix\nn: The number of columns of the matrix\nrow_pointer: row_pointer[i] indicates where in nzval the data for the i-th row starts\ncolumn_start: column_start[i] indicates at which column the first nonzero for the i-th row is\nnzval: The nonzero values in the matrix\n\n\n\n\n\n","category":"type"},{"location":"manual/#SplineGrids.DefaultControlPoints","page":"Manual","title":"SplineGrids.DefaultControlPoints","text":"DefaultControlPoints(control_points)\n\nA thin wrapper around an array of control point values.\n\n\n\n\n\n","category":"type"},{"location":"manual/#SplineGrids.LocalRefinement","page":"Manual","title":"SplineGrids.LocalRefinement","text":"LocalRefinement(\n    dims_refinement,\n    refinement_matrices,\n    refinement_indices,\n    refinement_values)\n\nThe data for performing a local refinement; one or more refinement matrices and the to be overwritten control point values after multiplication with the refinement matrices along the specified dimensions.\n\nFields\n\ndims_refinement: The dimensions along which will be refined\nrefinement_matrices: The matrices that perform the refinement\nrefinement_indices: The indices of the control points that will be overwritten after the refinement\nrefinement_values: The new values of the control points that will be rewritten after refinement\n\n\n\n\n\n","category":"type"},{"location":"manual/#SplineGrids.LocallyRefinedControlPoints","page":"Manual","title":"SplineGrids.LocallyRefinedControlPoints","text":"LocallyRefinedControlPoints(\n    control_points_base,\n    control_points_refined,\n    local_refinements)\n\nAll data required to perform multiple refinement steps and overwriting control point values along the way, yielding a Truncated Hierarchical Basis (THB) spline.\n\nFields\n\ncontrol_points_base: The densely defined control points at the basis of the hierarchy\ncontrol_points_refined: The intermediate and final control point arrays after applying the local refinements\nlocal_refinements: Data for local refinement for each step in the hierarchy\n\n\n\n\n\n","category":"type"},{"location":"manual/#SplineGrids.SplineGrid","page":"Manual","title":"SplineGrids.SplineGrid","text":"SplineGrid(\n    spline_dimensions,\n    control_points,\n    weights,\n    eval)\n\nThe SplineGrid is the central object of the SplineGrids.jl package, containing all information to evaluate the defined spline on the defined grid.\n\nFields\n\nspline_dimensions: A SplineDimension per dimension of the spline, containing data to evaluate basis functions.\ncontrol points: The points that define the shape of the spline, and in how many dimensions it is embedded.\nweights: Control point weights to define NURBS.\neval: The array where the evaluated spline grid is stored.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Utility-functions","page":"Manual","title":"Utility functions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"decompress\nget_n_control_points\nadd_default_local_refinement","category":"page"},{"location":"manual/#SplineGrids.decompress","page":"Manual","title":"SplineGrids.decompress","text":"decompress(\n    spline_dimension::SplineDimension{Tv}; derivative_order::Integer = 0) where {Tv}\n\nTransform spline_dimension.eval into a matrix of shape (n_sample_points, n_points - degree - 1) which explicitly gives the value for each basis function at each sample point.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SplineGrids.get_n_control_points","page":"Manual","title":"SplineGrids.get_n_control_points","text":"Get the number of control points within the control point object.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SplineGrids.add_default_local_refinement","page":"Manual","title":"SplineGrids.add_default_local_refinement","text":"add_default_local_refinement(spline_grid)\n\nRefine in the default way in every dimension, i.e. bisecting every non-trivial knot span. Yields a spline grid with a LocallyRefinedControlPoints object for the control_points field.\n\n\n\n\n\n","category":"function"},{"location":"examples_optics/#Lens-geometry-optimization-example","page":"Optimizing a lens surface","title":"Lens geometry optimization example","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"In this section we optimize the surface of a lens to yield a target irradiance distribution on a screen. This process is called caustic design. Below a schematic of the simulated setup is shown.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using CairoMakie # hide\nusing Makie.GeometryBasics # hide\n\nfig = Figure() # hide\nax = Axis(fig[1, 1]; xlabel = \"z axis\") # hide\n\n# Incoming beam # hide\nn_rays = 10 # hide\narrows!(ax, # hide\n    fill(-2.0, n_rays), # hide\n    range(-1, 1, length = n_rays), # hide\n    ones(n_rays),  # hide\n    zeros(n_rays), # hide\n    label = \"Incoming parallel beam\" # hide\n) # hide\n\n# Lens first surface # hide\nn_points = 100  # hide\ny_lens = range(-1, 1, length = n_points) # hide\nx_lens_1 = fill(-0.5, n_points) # hide\nlines!(ax, # hide\n    x_lens_1,  # hide\n    y_lens, # hide\n    label = \"Fixed lens surface\" # hide\n) # hide\n\n# Lens second surface # hide\nx_lens_2 = sin.(10y_lens) / 25  # hide\nlines!(ax, # hide\n    x_lens_2, # hide\n    y_lens, # hide\n    label = \"Lens surface to optimize\" # hide\n) # hide\n\n# Lens fill # hide\npoly!( # hide\n    ax, # hide\n    [ # hide\n        Point2f.(x_lens_1, y_lens)..., # hide\n        Point2f.(x_lens_2[end:-1:1], y_lens[end:-1:1])... # hide\n    ], # hide\n    color = (:blue, 0.2) # hide\n) # hide\n\n# Detector screen # hide\nlines!( # hide\n    ax, # hide\n    [2.0, 2.0], # hide\n    [-3.0, 3.0], # hide\n    label = \"Detector screen\" # hide\n) # hide\n\naxislegend(ax, position = :lt) # hide\nhidexdecorations!(ax, label = false) # hide\nhideydecorations!(ax) # hide\n\nfig # hide","category":"page"},{"location":"examples_optics/#Differentiable-ray-tracing-kernel","page":"Optimizing a lens surface","title":"Differentiable ray tracing kernel","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"Here we define a kernel which computes for each sample point on the surface:","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"at which direction a ray leaves that point by Snell's law;\nwhere that ray intersects the detector screen;\nWhat the contributions of that ray to the pixel values are.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"The contribution of the ray is smeared out over multiple pixels in a smooth way to make the rendering differentiable.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using KernelAbstractions\nusing Atomix\n\n# Kernel function for computing the contribution of a ray intersection to the\n# pixels close to the intersection.\nfunction F(x, x0, w)\n    if x < x0 - w\n        -one(x) / 2\n    elseif x > x0 + w\n        one(x) / 2\n    else\n        x_transformed = (x - x0) / w\n        (sin(π * x_transformed) / π + x_transformed) / 2\n    end\nend\n\n@kernel function ray_tracing_kernel(\n        render,\n        @Const(u),\n        @Const(∂₁u),\n        @Const(∂₂u),\n        @Const(x),\n        @Const(y),\n        r,\n        z_screen,\n        screen_size,\n        ray_kernel_size\n)\n    I = @index(Global, Cartesian)\n\n    u_I = u[I]\n    ∂₁u_I = ∂₁u[I]\n    ∂₂u_I = ∂₂u[I]\n\n    x_I = x[I[1]]\n    y_I = y[I[2]]\n\n    # x direction tangent vector: (1, 0, ∂₁u[I])\n    # y direction tangent vector: (0, 1, ∂₂u[I])\n    # -cross product (surface normal): n = (∂₁u[I], ∂₂u[I], -1) / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)\n    # light vector: ℓ = (0, 0, 1)\n    # Snell's law (vector form):\n    # c = -⟨n, ℓ⟩ = 1 / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)\n    # v = r * (0, 0, 1) + (r * c - √(1 - r^2 * (1 - c^2))) * (∂₁u[I], ∂₂u[I], -1) / √(1 + ∂₁u[I]^2 + ∂₁u[I]^2)\n\n    cross_product_norm = √(1 + ∂₁u_I^2 + ∂₂u_I^2)\n    c = 1 / cross_product_norm\n    sqrt_arg = 1 - r^2 * (1 - c^2)\n    if sqrt_arg >= 0\n        normal_vector_coef = (r * c - √(1 - r^2 * (1 - c^2))) / cross_product_norm\n\n        # Refracted ray direction\n        v_x = normal_vector_coef * ∂₁u_I\n        v_y = normal_vector_coef * ∂₂u_I\n        v_z = -normal_vector_coef + r\n\n        # Refracted ray starting point: (x_I, y_I, u_I)\n        t_screen_int = (z_screen - u_I) / v_z\n\n        if t_screen_int >= 0\n\n            # Screen intersection coordinates\n            x_screen = x_I + t_screen_int * v_x\n            y_screen = y_I + t_screen_int * v_y\n\n            # Pixel size\n            w_screen, h_screen = screen_size\n            n_x, n_y = size(render)\n            w_pixel = w_screen / n_x\n            h_pixel = h_screen / n_y\n\n            # Pixel intersection indices\n            n_x, n_y = size(render)\n\n            i = 1 + Int(floor((w_screen / 2 + x_screen) / w_pixel))\n            j = 1 + Int(floor((h_screen / 2 + y_screen) / h_pixel))\n\n            # Render contribution from this ray\n            i_min = max(i - ray_kernel_size[1] - 1, 1)\n            i_max = min(i + ray_kernel_size[1] + 1, n_x)\n            j_min = max(j - ray_kernel_size[2] - 1, 1)\n            j_max = min(j + ray_kernel_size[2] + 1, n_y)\n\n            w_kernel = (ray_kernel_size[1] + 0.5) * w_pixel\n            h_kernel = (ray_kernel_size[2] + 0.5) * h_pixel\n\n            for i_ in i_min:i_max\n                contribution_x = F(-0.5w_screen + i_ * w_pixel, x_screen, w_kernel) -\n                                 F(-0.5w_screen + (i_ - 1) * w_pixel, x_screen, w_kernel)\n\n                for j_ in j_min:j_max\n                    contribution_y = F(-0.5h_screen + j_ * h_pixel, y_screen, h_kernel) -\n                                     F(\n                        -0.5h_screen + (j_ - 1) * h_pixel, y_screen, h_kernel)\n\n                    Atomix.@atomic render[i_, j_] += contribution_x * contribution_y\n                end\n            end\n        end\n    end\nend","category":"page"},{"location":"examples_optics/#Calling-the-ray-tracing-kernel","page":"Optimizing a lens surface","title":"Calling the ray tracing kernel","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"Here we define a function which computes the input for the ray tracing kernel from a spline grid and then calls the kernel.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"function trace_rays!(render, control_points_flat, p)::Nothing\n    (; spline_grid, u, ∂₁u, ∂₂u) = p\n\n    control_points = reshape(control_points_flat, size(spline_grid.control_points))\n\n    evaluate!(spline_grid; control_points, eval = u)\n    evaluate!(spline_grid; control_points, eval = ∂₁u, derivative_order = (1, 0))\n    evaluate!(spline_grid; control_points, eval = ∂₂u, derivative_order = (0, 1))\n\n    render .= 0.0\n    backend = get_backend(u)\n\n    ray_tracing_kernel(backend)(\n        render,\n        u,\n        ∂₁u,\n        ∂₂u,\n        spline_grid.spline_dimensions[1].sample_points,\n        spline_grid.spline_dimensions[2].sample_points,\n        p.r,\n        p.z_screen,\n        p.screen_size,\n        p.ray_kernel_size,\n        ndrange = size(u)\n    )\n    synchronize(backend)\n    return nothing\nend","category":"page"},{"location":"examples_optics/#Tracing-the-first-rays","page":"Optimizing a lens surface","title":"Tracing the first rays","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"Let's define a flat spline surface and trace some rays. We expect to see a projection of the square lens onto the screen, as all rays travel parallel to the z-axis.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using SplineGrids\nusing Plots\n\nn_control_points = (50, 50)\ndegree = (2, 2)\nn_sample_points = (300, 300) # Determines grid of sampled rays\ndim_out = 1\nextent = (-1.0, 1.0) # Lens extent in both x and y direction\n\nspline_dimensions = SplineDimension.(\n    n_control_points, degree, n_sample_points; max_derivative_order = 1, extent)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid.control_points .= 0\n\np_render = (;\n    spline_grid,\n    u = similar(spline_grid.eval),\n    ∂₁u = similar(spline_grid.eval),\n    ∂₂u = similar(spline_grid.eval),\n    r = 1.4,\n    z_screen = 5.0,\n    screen_size = (4.0, 4.0),\n    ray_kernel_size = (3, 3),\n    screen_res = (250, 250)\n)\n\nrender = zeros(Float32, p_render.screen_res)\n\ntrace_rays!(render, vec(spline_grid.control_points), p_render)\n\nheatmap(render, aspect_ratio = :equal)","category":"page"},{"location":"examples_optics/#Defining-the-target-distribution","page":"Optimizing a lens surface","title":"Defining the target distribution","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"We define a normalized target distribution, which we will compare to normalized renders.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using LinearAlgebra\n\ntarget = [exp(-(x .^ 2 + y .^ 2)^2)\n          for\n          x in range(-p_render.screen_size[1] / 2, p_render.screen_size[1] / 2,\n    length = p_render.screen_res[1]),\ny in range(-p_render.screen_size[2] / 2, p_render.screen_size[2] / 2,\n    length = p_render.screen_res[2])]\n\nnormalize!(target)\n\nheatmap(target, aspect_ratio = :equal)","category":"page"},{"location":"examples_optics/#The-loss-function","page":"Optimizing a lens surface","title":"The loss function","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using Distances\n\nfunction image_loss(control_points_flat, target, render, p_render)\n    trace_rays!(render, control_points_flat, p_render)\n    normalize!(render)\n    Euclidean()(render, target)\nend\n\nrender = zeros(Float32, p_render.screen_res...)\n\nimage_loss(\n    vec(spline_grid.control_points),\n    target,\n    render,\n    p_render\n)","category":"page"},{"location":"examples_optics/#Gradients-w.r.t.-control-points","page":"Optimizing a lens surface","title":"Gradients w.r.t. control points","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"We can now compute the gradient of the loss function with respect to the control points. Let's have a look at it.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using Enzyme\n\nG = make_zero(vec(spline_grid.control_points))\ndrender = make_zero(render)\ndp_render = make_zero(p_render)\n\nautodiff(\n    Reverse,\n    image_loss,\n    Active,\n    Duplicated(vec(spline_grid.control_points), G),\n    Const(target),\n    DuplicatedNoNeed(render, drender),\n    DuplicatedNoNeed(p_render, dp_render)\n)\n\nheatmap(reshape(G, n_control_points), aspect_ratio = :equal)","category":"page"},{"location":"examples_optics/#Optimizing-the-surface","page":"Optimizing a lens surface","title":"Optimizing the surface","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"using Optimization\nusing OptimizationOptimJL: BFGS\n\nfunction image_loss_grad!(G, control_points_flat, meta_p)::Nothing\n    make_zero!(G)\n    make_zero!(meta_p.render_duplicated.dval)\n    for val in values(meta_p.p_render_duplicated.dval)\n        val isa Union{Array, SplineGrid} && make_zero!(val)\n    end\n    autodiff(\n        Reverse,\n        image_loss,\n        Active,\n        Duplicated(control_points_flat, G),\n        Const(meta_p.target),\n        meta_p.render_duplicated,\n        meta_p.p_render_duplicated\n    )\n    return nothing\nend\n\nmeta_p = (;\n    target,\n    render_duplicated = DuplicatedNoNeed(render, drender),\n    p_render_duplicated = DuplicatedNoNeed(p_render, dp_render)\n)\n\noptimization_function = OptimizationFunction(\n    (control_points_flat, p) -> image_loss(\n        control_points_flat,\n        target,\n        render,\n        p_render\n    ),\n    grad = image_loss_grad!\n)\n\nprob = OptimizationProblem(\n    optimization_function,\n    vec(spline_grid.control_points),\n    meta_p\n)\n\nsol = solve(prob, BFGS(); maxiters = 50)","category":"page"},{"location":"examples_optics/#Viewing-the-optimization-result","page":"Optimizing a lens surface","title":"Viewing the optimization result","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"The final render looks like this:","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"trace_rays!(render, sol.u, p_render)\nheatmap(render, aspect_ratio = :equal)","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"And the lens surface looks like this:","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"spline_grid.control_points .= reshape(sol.u, size(spline_grid.control_points))\nevaluate!(spline_grid)\nplot(spline_grid; plot_knots = false, aspect_ratio = :equal)","category":"page"},{"location":"examples_optics/#A-peek-into-upcoming-features","page":"Optimizing a lens surface","title":"A peek into upcoming features","text":"","category":"section"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"One of the neat things we can do with this setup is look at all sorts of gradients. We are most interested in the gradient of the loss with respect to the partial derivatives of the surface, since those are the most important for the rendering result. In particular, we look at the sum of the absolute values of these gradients. This shows which regions of the lens surface the loss is most sensitive to, and thus where the surface might need more degrees of freedom.","category":"page"},{"location":"examples_optics/","page":"Optimizing a lens surface","title":"Optimizing a lens surface","text":"function loss_from_grid(render, u, ∂₁u, ∂₂u, spline_grid, target, p_render)\n    backend = get_backend(u)\n    ray_tracing_kernel(backend)(\n        render,\n        u,\n        ∂₁u,\n        ∂₂u,\n        spline_grid.spline_dimensions[1].sample_points,\n        spline_grid.spline_dimensions[2].sample_points,\n        p_render.r,\n        p_render.z_screen,\n        p_render.screen_size,\n        p_render.ray_kernel_size,\n        ndrange = size(u)\n    )\n    synchronize(backend)\n    Euclidean()(render, target)\nend\n\nfor val in values(meta_p.p_render_duplicated.dval)\n    val isa Union{Array, SplineGrid} && make_zero!(val)\nend\nautodiff(\n    Reverse,\n    loss_from_grid,\n    Active,\n    meta_p.render_duplicated,\n    Duplicated(p_render.u, meta_p.p_render_duplicated.dval.u),\n    Duplicated(p_render.∂₁u, meta_p.p_render_duplicated.dval.∂₁u),\n    Duplicated(p_render.∂₂u, meta_p.p_render_duplicated.dval.∂₂u),\n    Duplicated(spline_grid, meta_p.p_render_duplicated.dval.spline_grid),\n    Const(target),\n    Const(p_render)\n)\n\nheatmap(\n    abs.(meta_p.p_render_duplicated.dval.∂₁u[:, :, 1]) +\n    abs.(meta_p.p_render_duplicated.dval.∂₂u[:, :, 1]),\n    aspect_ratio = :equal)","category":"page"},{"location":"examples_nurbs/#NURBS-example","page":"NURBS","title":"NURBS example","text":"","category":"section"},{"location":"examples_nurbs/","page":"NURBS","title":"NURBS","text":"NURBS allow you to specify a weight for each control point, giving an extra degree of freedom. The spline grid is non-linear in terms of the weights. NURBS allow you to specify certain geometries exactly that splines can only approximate, like conic sections. The example below shows an exact representation of the unit circle.","category":"page"},{"location":"examples_nurbs/","page":"NURBS","title":"NURBS","text":"using SplineGrids\nusing Plots\n\nn_control_points = 9\ndegree = 2\nn_sample_points = 500\ndim_out = 2\n\nknot_values = Float32[0, π / 2, π, 3π / 2, 2π]\nmultiplicities = Int32[3, 2, 2, 2, 3]\nknot_vector = KnotVector(knot_values, multiplicities)\n\nspline_dimension = SplineDimension(n_control_points, degree, n_sample_points; knot_vector)\nnurbs_grid = NURBSGrid(spline_dimension, dim_out)\nnurbs_grid.weights[2:2:end] .= 1 / sqrt(2)\nnurbs_grid.control_points .= [1 0;\n                              1 1;\n                              0 1;\n                              -1 1;\n                              -1 0;\n                              -1 -1;\n                              0 -1;\n                              1 -1;\n                              1 0]\nevaluate!(nurbs_grid)\nplot(nurbs_grid; aspect_ratio = :equal)","category":"page"},{"location":"examples_pde/#PDE-solving-example","page":"Solving a PDE","title":"PDE solving example","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"In this section we solve the following PDE problem with a spline grid:","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"beginalign*\nbegincases\n    u  Omega rightarrow mathbbR \n    Delta u = u^3 text for  mathbfx in Omega \n    u = g(mathbfx)  text for  mathbfx in partialOmega\nendcases\nendalign*","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"where the domain is given by the open unit cube: Omega = (01)^3. We assume that g(xyz) = 0 for z in (01) and g(xyz) = f(xy) for z = 0 1.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We solve this problem by sampling the domain and enforcing the PDE on the interior points and the boundary condition on the boundary points.","category":"page"},{"location":"examples_pde/#The-residual-kernel","page":"Solving a PDE","title":"The residual kernel","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We first define the kernel which calculates the residual of a given approximation to the solution of the problem above. Note that this kernel is agnostic of the fact that the solution will come from a spline grid.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"using KernelAbstractions\n\n@kernel function pde_residual_kernel(\n        residual,\n        @Const(f),\n        @Const(u),\n        @Const(∂₁²u),\n        @Const(∂₂²u),\n        @Const(∂₃²u)\n)\n    I = @index(Global, Cartesian)\n\n    is_boundary = false\n    for (i, i_max) in zip(Tuple(I)[1:(end - 1)], size(residual)[1:(end - 1)])\n        if (i == 1) || (i == i_max)\n            is_boundary = true\n            break\n        end\n    end\n\n    residual[I] = if is_boundary\n        if I[3] == 1 || I[3] == size(residual)[3]\n            u[I] - f[I[1], I[2]]\n        else\n            u[I]\n        end\n    else\n        ∂₁²u[I] + ∂₂²u[I] + ∂₃²u[I] - u[I]^3\n    end\nend","category":"page"},{"location":"examples_pde/#The-residual-as-a-function-of-the-spline-grid-control-points","page":"Solving a PDE","title":"The residual as a function of the spline grid control points","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"Whe now define a function which generates the input of the above residual kernel from a spline grid and computes the residual in place. It assumes a parameter object with the spline grid, f (an array that specifies the boundary condition for the bottom and top of the domain, the boundary condition is 0 elsewhere) and caches for the spline grid evaluation.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"function pde_residual!(residual, control_points_flat, p)::Nothing\n    (; spline_grid, f, u, ∂₁²u, ∂₂²u, ∂₃²u) = p\n\n    control_points = reshape(\n        control_points_flat,\n        size(spline_grid.control_points)\n    )\n\n    evaluate!(spline_grid; control_points, eval = u)\n    evaluate!(spline_grid; control_points, eval = ∂₁²u, derivative_order = (2, 0, 0))\n    evaluate!(spline_grid; control_points, eval = ∂₂²u, derivative_order = (0, 2, 0))\n    evaluate!(spline_grid; control_points, eval = ∂₃²u, derivative_order = (0, 0, 2))\n\n    backend = get_backend(u)\n    pde_residual_kernel(backend)(\n        reshape(residual, size(u)),\n        f,\n        u,\n        ∂₁²u,\n        ∂₂²u,\n        ∂₃²u,\n        ndrange = size(u)\n    )\n    synchronize(backend)\n    return nothing\nend","category":"page"},{"location":"examples_pde/#Defining-the-spline-grid","page":"Solving a PDE","title":"Defining the spline grid","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We would like to define a residual function mathbbR^N rightarrow mathbbR^N, i.e. the number of sample points must equal the number of control points. For each dimension the maximum derivative order is 2, to evaluate the result of the Laplacian operator on the spline.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"using SplineGrids\n\nn_control_points = (25, 25, 25)\ndegree = (2, 2, 2)\nn_sample_points = n_control_points\ndim_out = 1\n\nspline_dimensions = SplineDimension.(\n    n_control_points, degree, n_sample_points; max_derivative_order = 2)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\nspline_grid","category":"page"},{"location":"examples_pde/#Defining-the-boundary-condition","page":"Solving a PDE","title":"Defining the boundary condition","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We define a boundary condition inspired by the Julia logo.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"using GLMakie\n\nfunction hill(x, y, x0, y0, β)\n    r = sqrt((x - x0)^2 + (y - y0)^2)\n    return exp(-(r / β)^2)\nend\n\nfunction hills(x, y)\n    R = 0.25\n    out = 0.0\n    for θ in range(0, 2π, length = 4)[1:(end - 1)]\n        x0 = 0.5 + R * cos(θ)\n        y0 = 0.5 + R * sin(θ)\n        out += hill(x, y, x0, y0, R / 2)\n    end\n    return 100 * out\nend\n\nf = [hills.(x, y)\n     for\n     x in spline_dimensions[1].sample_points,\ny in spline_dimensions[2].sample_points]\n\nheatmap(f)","category":"page"},{"location":"examples_pde/#Defining-the-problem","page":"Solving a PDE","title":"Defining the problem","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"We will solve the problem with a Jacobian free Newton-Krylov method. To do this, we need to provide a Jacobian-vector product (JVP) function.","category":"page"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"using NonlinearSolve\nusing Enzyme\n\np = (;\n    spline_grid,\n    f,\n    u = similar(spline_grid.eval),\n    ∂₁²u = similar(spline_grid.eval),\n    ∂₂²u = similar(spline_grid.eval),\n    ∂₃²u = similar(spline_grid.eval)\n)\n\nmeta_p = (;\n    residual = similar(spline_grid.eval),\n    p_duplicated = DuplicatedNoNeed(p, make_zero(p))\n)\n\nfunction pde_residual_jvp!(Jv, v, control_points_flat, meta_p)::Nothing\n    for val in values(meta_p.p_duplicated.dval)\n        make_zero!(val)\n    end\n    autodiff(\n        Forward,\n        pde_residual!,\n        DuplicatedNoNeed(vec(meta_p.residual), Jv),\n        Duplicated(control_points_flat, v),\n        meta_p.p_duplicated\n    )\n    return nothing\nend\n\nnonlinear_function = NonlinearFunction(\n    (residual, control_points_flat, p_) -> pde_residual!(residual, control_points_flat, p);\n    jvp = pde_residual_jvp!\n)\n\n# Initial guess\nx0 = zeros(Float32, length(spline_grid.control_points))\n\nproblem = NonlinearProblem(\n    nonlinear_function,\n    x0,\n    meta_p\n)","category":"page"},{"location":"examples_pde/#Solving-the-problem","page":"Solving a PDE","title":"Solving the problem","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"sol = solve(problem, NewtonRaphson(linsolve = KrylovJL_GMRES()))","category":"page"},{"location":"examples_pde/#Viewing-the-solution","page":"Solving a PDE","title":"Viewing the solution","text":"","category":"section"},{"location":"examples_pde/","page":"Solving a PDE","title":"Solving a PDE","text":"spline_grid.control_points .= reshape(sol.u, size(spline_grid.control_points))\nevaluate!(spline_grid)\nfig = Figure()\nax, plt = volume(fig[1, 1], log.(spline_grid.eval[:, :, :, 1] .+ 1))\nColorbar(fig[1, 2], plt; label = L\"\\log(u + 1)\")\nfig","category":"page"},{"location":"examples_derivatives/#Derivatives-example","page":"Derivatives","title":"Derivatives example","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"The code below shows an example of how derivatives can be used to compute the normal vectors of a surface.","category":"page"},{"location":"examples_derivatives/#Defining-the-surface","page":"Derivatives","title":"Defining the surface","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using SplineGrids\n\n# Spline Grid Parameters\nn_control_points = (5, 5)\ndegree = (2, 2)\nn_sample_points = (100, 100)\nNout = 3\nmax_derivative_order = 1\n\n# Define the spline grid\nspline_dimensions = SplineDimension.(\n    n_control_points, degree, n_sample_points; max_derivative_order)\nspline_grid = SplineGrid(spline_dimensions, Nout)\nfor i in 1:n_control_points[1]\n    for j in 1:n_control_points[2]\n        spline_grid.control_points[i, j, 3] = exp(-((i - 3)^2 + (j - 3)^2))\n    end\nend","category":"page"},{"location":"examples_derivatives/#Inspecting-the-basis-functions","page":"Derivatives","title":"Inspecting the basis functions","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"Let's look at the basis functions for the first dimension:","category":"page"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using Plots\n\nplot(spline_dimensions[1])","category":"page"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"and the derivatives of these basis functions:","category":"page"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using Plots\n\nplot(spline_dimensions[1]; derivative_order = 1)","category":"page"},{"location":"examples_derivatives/#Evaluating-the-surface","page":"Derivatives","title":"Evaluating the surface","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"The data is copied because spline_grid.eval will be overwritten below when computing the partial derivatives.","category":"page"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"evaluate!(spline_grid)\nspline_grid_data = copy(spline_grid.eval)\nnothing","category":"page"},{"location":"examples_derivatives/#Computing-the-partial-derivatives","page":"Derivatives","title":"Computing the partial derivatives","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"# Derivatives of the surface with respect to the first dimension parameter\nevaluate!(spline_grid; derivative_order = (1, 0))\n∂₁spline_grid_data = copy(spline_grid.eval)\n\n# Derivatives of the surface with respect to the second dimension parameter\nevaluate!(spline_grid; derivative_order = (0, 1))\n∂₂spline_grid_data = spline_grid.eval\nnothing","category":"page"},{"location":"examples_derivatives/#Computing-the-normal-vectors","page":"Derivatives","title":"Computing the normal vectors","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using LinearAlgebra\n\nnormal_vectors = similar(spline_grid_data)\nfor i in 1:n_sample_points[1]\n    for j in 1:n_sample_points[2]\n        normal_vectors[i, j, :] .= cross(\n            view(∂₁spline_grid_data, i, j, :),\n            view(∂₂spline_grid_data, i, j, :)\n        )\n        normal_vectors[i, j, :] ./= 10 * norm(view(normal_vectors, i, j, :))\n    end\nend","category":"page"},{"location":"examples_derivatives/#Plotting","page":"Derivatives","title":"Plotting","text":"","category":"section"},{"location":"examples_derivatives/","page":"Derivatives","title":"Derivatives","text":"using CairoMakie\n\n# Plotting the surface\nf = Figure()\nax = Axis3(f[1, 1])\nCairoMakie.surface!(ax, eachslice(spline_grid_data, dims = 3)...)\n\n# Plotting a subset of the normal vectors\nspline_grid_data_reshaped = reshape(spline_grid_data, (prod(n_sample_points), 3))\nnormal_vectors_reshaped = reshape(normal_vectors, (prod(n_sample_points), 3))\n\nCairoMakie.quiver!(\n    ax,\n    eachslice(view(spline_grid_data_reshaped, 1:192:prod(n_sample_points), :), dims = 2)...,\n    eachslice(view(normal_vectors_reshaped, 1:192:prod(n_sample_points), :), dims = 2)...,\n    arrowsize = 0.03\n)\n\nCairoMakie.xlims!(0, 1)\nCairoMakie.ylims!(0, 1)\n\nf","category":"page"},{"location":"examples_dimensions/#Dimensionality-examples","page":"Dimensionality","title":"Dimensionality examples","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"This page shows examples of spline grids of various dimensionalities via their plotting recipes.","category":"page"},{"location":"examples_dimensions/#1-input,-1-output","page":"Dimensionality","title":"1 input, 1 output","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"using SplineGrids\nusing Plots\n\n# Spline grid parameters\nn_control_points = 10\ndegree = 3\nn_sample_points = 250\ndim_out = 1\n\n# Define spline grid\nspline_dimension = SplineDimension(\n    n_control_points, degree, n_sample_points, extent = (3.0, 5.0))\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nspline_grid.control_points .= [\n    0.342, 0.633, 0.446, 0.716, 0.843, 0.171, 0.061, 0.973, 0.057, 0.671]\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#1-input,-2-outputs","page":"Dimensionality","title":"1 input, 2 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = 10\ndegree = 2\nn_sample_points = 250\ndim_out = 2\n\n# Define spline grid\nspline_dimension = SplineDimension(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nr = 1:n_control_points\nθ = 1:n_control_points\nspline_grid.control_points[:, 1] .= @. r * cos(θ)\nspline_grid.control_points[:, 2] .= @. r * sin(θ)\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#1-input,-3-outputs","page":"Dimensionality","title":"1 input, 3 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = 10\ndegree = 2\nn_sample_points = 250\ndim_out = 3\n\n# Define spline grid\nspline_dimension = SplineDimension(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nr = 1:n_control_points\nθ = 1:n_control_points\nz = 1:n_control_points\nspline_grid.control_points[:, 1] .= @. r * cos(θ)\nspline_grid.control_points[:, 2] .= @. r * sin(θ)\nspline_grid.control_points[:, 3] .= z\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#1-input,-4-outputs","page":"Dimensionality","title":"1 input, 4 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = 10\ndegree = 2\nn_sample_points = 250\ndim_out = 4\n\n# Define spline grid\nspline_dimension = SplineDimension(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nr = 1:n_control_points\nθ = 1:n_control_points\nz = 1:n_control_points\nc = sin.(z)\nspline_grid.control_points[:, 1] .= @. r * cos(θ)\nspline_grid.control_points[:, 2] .= @. r * sin(θ)\nspline_grid.control_points[:, 3] .= z\nspline_grid.control_points[:, 4] .= c\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#2-inputs,-1-output","page":"Dimensionality","title":"2 inputs, 1 output","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = (5, 6)\ndegree = (2, 2)\nn_sample_points = (60, 50)\ndim_out = 1\n\n# Define spline grid\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\n\n# Set control points\nspline_grid.control_points .= 0\nspline_grid.control_points[1:2:end] .= 1:(prod(n_control_points) / 2)\n\n# Evaluate spline grid \nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#2-inputs,-2-outputs","page":"Dimensionality","title":"2 inputs, 2 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = (4, 4)\ndegree = (2, 3)\nn_sample_points = (15, 20)\ndim_out = 2\n\n# Define spline grid\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, dim_out)\n\n# Set control points\nspline_grid.control_points .= [-0.358 0.795 -0.016 -0.295; 0.923 -0.182 -0.644 0.612; -0.91 0.708 -0.426 0.412; 0.56 -0.78 0.515 0.676;;;\n                               0.938 0.393 -0.702 -0.99; -0.578 0.305 -0.842 -0.57; 0.034 -0.813 -0.514 0.162; -0.016 -0.822 -0.261 -0.148]\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"examples_dimensions/#2-inputs,-3-outputs","page":"Dimensionality","title":"2 inputs, 3 outputs","text":"","category":"section"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"# Spline grid parameters\nn_control_points = (25, 2)\ndegree = (3, 1)\nn_sample_points = (100, 100)\ndim_out = 3\n\n# Define spline grid\nspline_dimension = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimension, dim_out)\n\n# Set control points\nR = 3\nr = 1\nρ = range(-r, r, length = n_control_points[2])\nfor (i, θ) in enumerate(range(0, 2π, length = n_control_points[1]))\n    ϕ = 2θ\n    spline_grid.control_points[i, :, 1] .= @. (R + ρ * cos(ϕ)) * cos(θ)\n    spline_grid.control_points[i, :, 2] .= @. (R + ρ * cos(ϕ)) * sin(θ)\n    spline_grid.control_points[i, :, 3] .= ρ * sin(ϕ)\nend\n\n# Evaluate spline grid\nevaluate!(spline_grid)\n\n# Plot\nplot(spline_grid)","category":"page"},{"location":"examples_dimensions/","page":"Dimensionality","title":"Dimensionality","text":"spline_grid","category":"page"},{"location":"#SplineGrids.jl","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"","category":"section"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"SplineGrids.jl is designed to efficiently evaluate a broad class of spline objects on a grid in the spline's domain. The package supports:","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"Any number of input and output dimensions (see the Dimensionality examples)\nAny degree of basis functions and type of knot vector\nUsing weights to define NURBS (see the NURBS example)\nAny combination of partial derivatives (not for NURBS)\nLocal refinement (see the theory section on Local refinement)\nCPU and GPU backends via KernelAbstractions.jl","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"The intended use case of this package is to be integrated into the SciML ecosystem, for easy and efficient incorporation of spline geometries in problems of fitting (Linear fitting example), optimization (Lens geometry optimization example), differential equation solving (PDE solving example) and machine learning. Since SplineGrids.jl makes heavy use of in-place computations, the recommended automatic differentiation framework to use with SplineGrids.jl is Enzyme.","category":"page"},{"location":"#API","page":"SplineGrids.jl","title":"API","text":"","category":"section"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"using SplineGrids\n\n# Parameters per input dimension\nn_control_points = (10, 10, 5)\ndegree = (2, 3, 2)\nn_sample_points = (50, 50, 25)\n\n# The number of output dimensions\nNout = 4\n\n# Defining the spline grid\nspline_dimensions = SplineDimension.(n_control_points, degree, n_sample_points)\nspline_grid = SplineGrid(spline_dimensions, Nout)\n\n# Set the desired control points\nspline_grid.control_points .= rand(n_control_points..., Nout)\n\n# Evaluate\nevaluate!(spline_grid)\n\n# The output can be found in spline_grid.eval of shape (n_sample_points..., Nout)","category":"page"},{"location":"#History-and-theory","page":"SplineGrids.jl","title":"History and theory","text":"","category":"section"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"The most well known introduction to spline theory is probably The NURBS book [1].","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"SplineGrids.jl was inspired by work on caustic design by optimizing spline-based lens surfaces with differentiable ray tracing. This work was published in a master thesis and later in follow-up research [2][3][4].","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"Some of the core ideas for this package where implemented earlier in NURBS Pytorch, but that package was never properly tested or released.","category":"page"},{"location":"#References","page":"SplineGrids.jl","title":"References","text":"","category":"section"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"[1] Piegl, L., & Tiller, W. (2012). The NURBS book. Springer Science & Business Media.","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"[2] Koning, B. D., Heemels, A., Adam, A., & Möller, M. (2024). Gradient descent-based freeform optics design for illumination using algorithmic differentiable non-sequential ray tracing. Optimization and Engineering, 25(3), 1203-1235.","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"[3] Heemels, A., De Koning, B., Möller, M., & Adam, A. (2024). Optimizing freeform lenses for extended sources with algorithmic differentiable ray tracing and truncated hierarchical B-splines. Optics Express, 32(6), 9730-9746.","category":"page"},{"location":"","page":"SplineGrids.jl","title":"SplineGrids.jl","text":"[4] Heemels, A., de Koning, B., Moller, M., & Adama, A. (2024, May). Unsupervised design of illumination optics using algorithmic differentiable raytracing. In International Optical Design Conference 2023 (Vol. 12798, pp. 84-85). SPIE.","category":"page"}]
}

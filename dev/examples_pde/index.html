<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving a PDE · SplineGrids.jl</title><meta name="title" content="Solving a PDE · SplineGrids.jl"/><meta property="og:title" content="Solving a PDE · SplineGrids.jl"/><meta property="twitter:title" content="Solving a PDE · SplineGrids.jl"/><meta name="description" content="Documentation for SplineGrids.jl."/><meta property="og:description" content="Documentation for SplineGrids.jl."/><meta property="twitter:description" content="Documentation for SplineGrids.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SplineGrids.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SplineGrids.jl</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../theory_refinement/">Refinement</a></li><li><a class="tocitem" href="../theory_local_refinement/">Local refinement (THB-splines)</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_dimensions/">Dimensionality</a></li><li><a class="tocitem" href="../examples_nurbs/">NURBS</a></li><li><a class="tocitem" href="../examples_derivatives/">Derivatives</a></li><li><a class="tocitem" href="../examples_linear_fitting/">Linear fitting</a></li><li><a class="tocitem" href="../examples_enzyme/">Control point derivatives with Enzyme</a></li></ul></li><li><span class="tocitem">Advanced examples</span><ul><li class="is-active"><a class="tocitem" href>Solving a PDE</a><ul class="internal"><li><a class="tocitem" href="#The-residual-kernel"><span>The residual kernel</span></a></li><li><a class="tocitem" href="#The-residual-as-a-function-of-the-spline-grid-control-points"><span>The residual as a function of the spline grid control points</span></a></li><li><a class="tocitem" href="#Defining-the-spline-grid"><span>Defining the spline grid</span></a></li><li><a class="tocitem" href="#Defining-the-boundary-condition"><span>Defining the boundary condition</span></a></li><li><a class="tocitem" href="#Defining-the-problem"><span>Defining the problem</span></a></li><li><a class="tocitem" href="#Solving-the-problem"><span>Solving the problem</span></a></li><li><a class="tocitem" href="#Viewing-the-solution"><span>Viewing the solution</span></a></li></ul></li><li><a class="tocitem" href="../examples_optics/">Optimizing a lens surface</a></li></ul></li><li><a class="tocitem" href="../manual/">Manual</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced examples</a></li><li class="is-active"><a href>Solving a PDE</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving a PDE</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SouthEndMusic/SplineGrids.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SouthEndMusic/SplineGrids.jl/blob/master/docs/src/examples_pde.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PDE-solving-example"><a class="docs-heading-anchor" href="#PDE-solving-example">PDE solving example</a><a id="PDE-solving-example-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-solving-example" title="Permalink"></a></h1><p>In this section we solve the following PDE problem with a spline grid:</p><p class="math-container">\[\begin{align*}
\begin{cases}
    u : \Omega \rightarrow \mathbb{R} \\
    \Delta u = u^3 &amp;\text{ for }&amp; \mathbf{x} \in \Omega \\
    u = g(\mathbf{x}) \; &amp;\text{ for }&amp; \mathbf{x} \in \partial\Omega
\end{cases}
\end{align*},\]</p><p>where the domain is given by the open unit cube: <span>$\Omega = (0,1)^3$</span>. We assume that <span>$g(x,y,z) = 0$</span> for <span>$z \in (0,1)$</span> and <span>$g(x,y,z) = f(x,y)$</span> for <span>$z = 0, 1$</span>.</p><p>We solve this problem by sampling the domain and enforcing the PDE on the interior points and the boundary condition on the boundary points.</p><h2 id="The-residual-kernel"><a class="docs-heading-anchor" href="#The-residual-kernel">The residual kernel</a><a id="The-residual-kernel-1"></a><a class="docs-heading-anchor-permalink" href="#The-residual-kernel" title="Permalink"></a></h2><p>We first define the kernel which calculates the residual of a given approximation to the solution of the problem above. Note that this kernel is agnostic of the fact that the solution will come from a spline grid.</p><pre><code class="language-julia hljs">using KernelAbstractions

@kernel function pde_residual_kernel(
        residual,
        @Const(f),
        @Const(u),
        @Const(∂₁²u),
        @Const(∂₂²u),
        @Const(∂₃²u)
)
    I = @index(Global, Cartesian)

    is_boundary = false
    for (i, i_max) in zip(Tuple(I)[1:(end - 1)], size(residual)[1:(end - 1)])
        if (i == 1) || (i == i_max)
            is_boundary = true
            break
        end
    end

    residual[I] = if is_boundary
        if I[3] == 1 || I[3] == size(residual)[3]
            u[I] - f[I[1], I[2]]
        else
            u[I]
        end
    else
        ∂₁²u[I] + ∂₂²u[I] + ∂₃²u[I] - u[I]^3
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">pde_residual_kernel (generic function with 4 methods)</code></pre><h2 id="The-residual-as-a-function-of-the-spline-grid-control-points"><a class="docs-heading-anchor" href="#The-residual-as-a-function-of-the-spline-grid-control-points">The residual as a function of the spline grid control points</a><a id="The-residual-as-a-function-of-the-spline-grid-control-points-1"></a><a class="docs-heading-anchor-permalink" href="#The-residual-as-a-function-of-the-spline-grid-control-points" title="Permalink"></a></h2><p>Whe now define a function which generates the input of the above residual kernel from a spline grid and computes the residual in place. It assumes a parameter object with the spline grid, <code>f</code> (an array that specifies the boundary condition for the bottom and top of the domain, the boundary condition is <code>0</code> elsewhere) and caches for the spline grid evaluation.</p><pre><code class="language-julia hljs">function pde_residual!(residual, control_points_flat, p)::Nothing
    (; spline_grid, f, u, ∂₁²u, ∂₂²u, ∂₃²u) = p

    control_points = reshape(
        control_points_flat,
        size(spline_grid.control_points)
    )

    evaluate!(spline_grid; control_points, eval = u)
    evaluate!(spline_grid; control_points, eval = ∂₁²u, derivative_order = (2, 0, 0))
    evaluate!(spline_grid; control_points, eval = ∂₂²u, derivative_order = (0, 2, 0))
    evaluate!(spline_grid; control_points, eval = ∂₃²u, derivative_order = (0, 0, 2))

    backend = get_backend(u)
    pde_residual_kernel(backend)(
        reshape(residual, size(u)),
        f,
        u,
        ∂₁²u,
        ∂₂²u,
        ∂₃²u,
        ndrange = size(u)
    )
    synchronize(backend)
    return nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">pde_residual! (generic function with 1 method)</code></pre><h2 id="Defining-the-spline-grid"><a class="docs-heading-anchor" href="#Defining-the-spline-grid">Defining the spline grid</a><a id="Defining-the-spline-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-spline-grid" title="Permalink"></a></h2><p>We would like to define a residual function <span>$\mathbb{R}^N \rightarrow \mathbb{R}^N$</span>, i.e. the number of sample points must equal the number of control points. For each dimension the maximum derivative order is 2, to evaluate the result of the Laplacian operator on the spline.</p><pre><code class="language-julia hljs">using SplineGrids

n_control_points = (25, 25, 25)
degree = (2, 2, 2)
n_sample_points = n_control_points
dim_out = 1

spline_dimensions = SplineDimension.(
    n_control_points, degree, n_sample_points; max_derivative_order = 2)
spline_grid = SplineGrid(spline_dimensions, dim_out)
spline_grid</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SplineGrid volume with outputs in ℝ¹ (Float32)
----------------------------------------------
* Properties per dimension:
┌─────────────────┬────────┬───────────────────┬─────────────────┐
│<span class="sgr1"> input dimension │ degree │ # basis functions │ # sample points │
├─────────────────┼────────┼───────────────────┼─────────────────┤
│               1 │      2 │                25 │              25 │
│               2 │      2 │                25 │              25 │
│               3 │      2 │                25 │              25 │
└─────────────────┴────────┴───────────────────┴─────────────────┘
* Control points:
DefaultControlPoints for grid of size (25, 25, 25) in ℝ¹ (Float32).
</span></code></pre><h2 id="Defining-the-boundary-condition"><a class="docs-heading-anchor" href="#Defining-the-boundary-condition">Defining the boundary condition</a><a id="Defining-the-boundary-condition-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-boundary-condition" title="Permalink"></a></h2><p>We define a boundary condition inspired by the Julia logo.</p><pre><code class="language-julia hljs">using GLMakie

function hill(x, y, x0, y0, β)
    r = sqrt((x - x0)^2 + (y - y0)^2)
    return exp(-(r / β)^2)
end

function hills(x, y)
    R = 0.25
    out = 0.0
    for θ in range(0, 2π, length = 4)[1:(end - 1)]
        x0 = 0.5 + R * cos(θ)
        y0 = 0.5 + R * sin(θ)
        out += hill(x, y, x0, y0, R / 2)
    end
    return 100 * out
end

f = [hills.(x, y)
     for
     x in spline_dimensions[1].sample_points,
y in spline_dimensions[2].sample_points]

heatmap(f)</code></pre><img src="a3ba03ba.png" alt="Example block output"/><h2 id="Defining-the-problem"><a class="docs-heading-anchor" href="#Defining-the-problem">Defining the problem</a><a id="Defining-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-problem" title="Permalink"></a></h2><p>We will solve the problem with a Jacobian free Newton-Krylov method. To do this, we need to provide a Jacobian-vector product (JVP) function.</p><pre><code class="language-julia hljs">using NonlinearSolve
using Enzyme

p = (;
    spline_grid,
    f,
    u = similar(spline_grid.eval),
    ∂₁²u = similar(spline_grid.eval),
    ∂₂²u = similar(spline_grid.eval),
    ∂₃²u = similar(spline_grid.eval)
)

meta_p = (;
    residual = similar(spline_grid.eval),
    p_duplicated = DuplicatedNoNeed(p, make_zero(p))
)

function pde_residual_jvp!(Jv, v, control_points_flat, meta_p)::Nothing
    for val in values(meta_p.p_duplicated.dval)
        make_zero!(val)
    end
    autodiff(
        Forward,
        pde_residual!,
        DuplicatedNoNeed(vec(meta_p.residual), Jv),
        Duplicated(control_points_flat, v),
        meta_p.p_duplicated
    )
    return nothing
end

nonlinear_function = NonlinearFunction(
    (residual, control_points_flat, p_) -&gt; pde_residual!(residual, control_points_flat, p);
    jvp = pde_residual_jvp!
)

# Initial guess
x0 = zeros(Float32, length(spline_grid.control_points))

problem = NonlinearProblem(
    nonlinear_function,
    x0,
    meta_p
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">NonlinearProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float32}</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
u0: 15625-element Vector{Float32}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre><h2 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h2><pre><code class="language-julia hljs">sol = solve(problem, NewtonRaphson(linsolve = KrylovJL_GMRES()))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: MaxIters
u: 15625-element Vector{Float32}:
 7.203033f-5
 0.00012896715
 0.00088540546
 0.004786132
 0.020288704
 0.06699376
 0.17124008
 0.33741593
 0.512363
 0.6007665
 ⋮
 0.0013418678
 0.00020978265
 3.4804158f-5
 1.1672109f-5
 6.2266195f-6
 2.9949101f-6
 1.1428368f-6
 3.4744426f-7
 2.0612349f-7</code></pre><h2 id="Viewing-the-solution"><a class="docs-heading-anchor" href="#Viewing-the-solution">Viewing the solution</a><a id="Viewing-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Viewing-the-solution" title="Permalink"></a></h2><pre><code class="language-julia hljs">spline_grid.control_points .= reshape(sol.u, size(spline_grid.control_points))
evaluate!(spline_grid)
fig = Figure()
ax, plt = volume(fig[1, 1], log.(spline_grid.eval[:, :, :, 1] .+ 1))
Colorbar(fig[1, 2], plt; label = L&quot;\log(u + 1)&quot;)
fig</code></pre><img src="23a8c715.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples_enzyme/">« Control point derivatives with Enzyme</a><a class="docs-footer-nextpage" href="../examples_optics/">Optimizing a lens surface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 1 February 2025 20:32">Saturday 1 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
